Job <28522007> is submitted to default queue <inter>.
# Parameters:
# instance.parameter=value       #(type, mode) default = 'def value' : description : [min..max]
#----------------------------------------------------------------------------------------------
disable_trickbox=0                                    # (bool  , init-time) default = '0'      : Disable trickbox
trickbox_base=0x13000000                              # (int   , init-time) default = '0x13000000' : Base address for the trickbox. This must be 4KB aligned for the trickbox to operate correctly.
trickbox.separate_sec_mem=0                           # (bool  , init-time) default = '0'      : Separate secure memory
l2cc_base=0x13200000                                  # (int   , init-time) default = '0x13200000' : Base address for the l2cc
ram_fill_pattern_1=0xDFDFDFCF                         # (int   , init-time) default = '0xDFDFDFCF' : RAM Fill Pattern 1
ram_fill_pattern_2=0xCFDFDFDF                         # (int   , init-time) default = '0xCFDFDFDF' : RAM Fill Pattern 2
VALIDATION_treat_cmo_as_NOP=0                         # (bool  , init-time) default = '0'      : For testing coherent systems
counter_addr=0x0                                      # (int   , init-time) default = '0x0'    : Address for memory-mapped system counter block.  0 means the counter is not mapped, otherwise the address must be 4KB aligned.
dbg_rom_addr=0x22000000                               # (int   , init-time) default = '0x22000000' : Address of the start of the debug bus in main memory. : [0x0..0xFFFFFFFFFFFF]
dbg_bus_mmap_size=0x1                                 # (int   , init-time) default = '0x1'    : Size of the debug bus's mapping in main memory.  Values less than 4KB are reserved and have special meaning: 1, the size of the mapping is automatically determined.  Values of 4KB and larger are used as-is. : [0x0..0xFFFFFFFFFFFF]
cpu.NUM_CORES=0x4                                     # (int   , init-time) default = '0x4'    :  : [0x1..0x8]
enable-internal-vgic=1                                # (bool  , init-time) default = '1'      : Use CPU cluster internal GIC to handle interrupts
enable-gicv3=0                                        # (bool  , init-time) default = '0'      : Use GICv3 in the system
gicv2-only=0                                          # (bool  , init-time) default = '0'      : When using GICv3 system, pretend to be a GICv2
gicv3.CPU-affinities="0.0.0.0, 0.0.0.1, 0.0.0.2, 0.0.0.3"  # (string, init-time) default = '0.0.0.0, 0.0.0.1, 0.0.0.2, 0.0.0.3' : GICv3 affinity addresses for each CPU.
has-gicv4.1=0                                         # (bool  , init-time) default = '0'      : Use GICv4.1 in the system
VAL_force_slow_memory=0                               # (bool  , init-time) default = '0'      : Force all memory accesses into the slow path
VALIDATION_disable_epd=0                              # (bool  , run-time ) default = '0'      : For the purposes of test generation ONLY, force TCR_ELx.EPDx to behave as 0
VCPUMNTIRQ-PPI-ID=0x19                                # (int   , init-time) default = '0x19'   : PPI ID to connect the VCPUMNTIRQ to on the redistributor, PPI IDs are between 16 and 31, values 22, 23, 24, 26, 27, 29, 30 may cause unpredictable behaviours as they are already used : [0x10..0x1F]
cpu.cpu0.CONFIG64=1                                   # (bool  , init-time) default = '1'      : 
cpu.cpu0.CFGEND=0                                     # (bool  , init-time) default = '0'      : Big-endian mode for accessing configuration registers out of reset
cpu.cpu0.CP15SDISABLE=0                               # (bool  , init-time) default = '0'      : 
cpu.cpu0.CP15SDISABLE2=0                              # (bool  , init-time) default = '0'      : 
cpu.cpu0.TEINIT=0                                     # (bool  , init-time) default = '0'      : 
cpu.cpu0.VINITHI=0                                    # (bool  , init-time) default = '0'      : 
cpu.cpu1.CONFIG64=1                                   # (bool  , init-time) default = '1'      : 
cpu.cpu1.CFGEND=0                                     # (bool  , init-time) default = '0'      : Big-endian mode for accessing configuration registers out of reset
cpu.cpu1.CP15SDISABLE=0                               # (bool  , init-time) default = '0'      : 
cpu.cpu1.CP15SDISABLE2=0                              # (bool  , init-time) default = '0'      : 
cpu.cpu1.TEINIT=0                                     # (bool  , init-time) default = '0'      : 
cpu.cpu1.VINITHI=0                                    # (bool  , init-time) default = '0'      : 
cpu.cpu2.CONFIG64=1                                   # (bool  , init-time) default = '1'      : 
cpu.cpu2.CFGEND=0                                     # (bool  , init-time) default = '0'      : Big-endian mode for accessing configuration registers out of reset
cpu.cpu2.CP15SDISABLE=0                               # (bool  , init-time) default = '0'      : 
cpu.cpu2.CP15SDISABLE2=0                              # (bool  , init-time) default = '0'      : 
cpu.cpu2.TEINIT=0                                     # (bool  , init-time) default = '0'      : 
cpu.cpu2.VINITHI=0                                    # (bool  , init-time) default = '0'      : 
cpu.cpu3.CONFIG64=1                                   # (bool  , init-time) default = '1'      : 
cpu.cpu3.CFGEND=0                                     # (bool  , init-time) default = '0'      : Big-endian mode for accessing configuration registers out of reset
cpu.cpu3.CP15SDISABLE=0                               # (bool  , init-time) default = '0'      : 
cpu.cpu3.CP15SDISABLE2=0                              # (bool  , init-time) default = '0'      : 
cpu.cpu3.TEINIT=0                                     # (bool  , init-time) default = '0'      : 
cpu.cpu3.VINITHI=0                                    # (bool  , init-time) default = '0'      : 
cpu.cpu4.CONFIG64=1                                   # (bool  , init-time) default = '1'      : 
cpu.cpu4.CFGEND=0                                     # (bool  , init-time) default = '0'      : Big-endian mode for accessing configuration registers out of reset
cpu.cpu4.CP15SDISABLE=0                               # (bool  , init-time) default = '0'      : 
cpu.cpu4.CP15SDISABLE2=0                              # (bool  , init-time) default = '0'      : 
cpu.cpu4.TEINIT=0                                     # (bool  , init-time) default = '0'      : 
cpu.cpu4.VINITHI=0                                    # (bool  , init-time) default = '0'      : 
cpu.cpu5.CONFIG64=1                                   # (bool  , init-time) default = '1'      : 
cpu.cpu5.CFGEND=0                                     # (bool  , init-time) default = '0'      : Big-endian mode for accessing configuration registers out of reset
cpu.cpu5.CP15SDISABLE=0                               # (bool  , init-time) default = '0'      : 
cpu.cpu5.CP15SDISABLE2=0                              # (bool  , init-time) default = '0'      : 
cpu.cpu5.TEINIT=0                                     # (bool  , init-time) default = '0'      : 
cpu.cpu5.VINITHI=0                                    # (bool  , init-time) default = '0'      : 
cpu.cpu6.CONFIG64=1                                   # (bool  , init-time) default = '1'      : 
cpu.cpu6.CFGEND=0                                     # (bool  , init-time) default = '0'      : Big-endian mode for accessing configuration registers out of reset
cpu.cpu6.CP15SDISABLE=0                               # (bool  , init-time) default = '0'      : 
cpu.cpu6.CP15SDISABLE2=0                              # (bool  , init-time) default = '0'      : 
cpu.cpu6.TEINIT=0                                     # (bool  , init-time) default = '0'      : 
cpu.cpu6.VINITHI=0                                    # (bool  , init-time) default = '0'      : 
cpu.cpu7.CONFIG64=1                                   # (bool  , init-time) default = '1'      : 
cpu.cpu7.CFGEND=0                                     # (bool  , init-time) default = '0'      : Big-endian mode for accessing configuration registers out of reset
cpu.cpu7.CP15SDISABLE=0                               # (bool  , init-time) default = '0'      : 
cpu.cpu7.CP15SDISABLE2=0                              # (bool  , init-time) default = '0'      : 
cpu.cpu7.TEINIT=0                                     # (bool  , init-time) default = '0'      : 
cpu.cpu7.VINITHI=0                                    # (bool  , init-time) default = '0'      : 
cpu.has_thumb2ee=0x0                                  # (int   , init-time) default = '0x0'    : Dummy parameter - thumb2ee is not available : [0x0..0x0]
enable_atomic_op_filter=0                             # (bool  , init-time) default = '0'      : Whether atomic operations are converted to read-modify-write by bus
cpu.VAL_treat_e2h_rao=0                               # (bool  , init-time) default = '0'      : Implement HCR_EL2.E2H as a RES1 bit
elfloader.elf=""                                      # (string, init-time) default = ''       : ELF file
elfloader.lfile=""                                    # (string, init-time) default = ''       : load file for large address mapping
elfloader.ns_copy=1                                   # (bool  , init-time) default = '1'      : copy whole file to NS memory space
secure_switch.secure=0x1                              # (int   , run-time ) default = '0x1'    : Secure Port
secure_switch.normal=0x2                              # (int   , run-time ) default = '0x2'    : Normal Port
secure_switch.pvbus_mapper.handling_of_dvm_messages_from_upstream="forward"  # (string, init-time) default = 'forward' : What to do with DVM (Distributed Virtual Memory) messages received from upstream.  The options are to 'forward' them downstream unaltered, to 'terminate' them, or to 'handle' them locally and get called through handleUpstreamDVMMessage()
secure_switch.pvbus_mapper.handling_of_dvm_messages_from_downstream="forward"  # (string, init-time) default = 'forward' : What to do with DVM (Distributed Virtual Memory) messages received from downstream.  The options are to 'forward' them upstream unaltered, to 'terminate' them, or to 'handle' them locally and get called through handleDownstreamDVMMessage()
secure_switch.pvbus_mapper.handling_of_upstream_snoop_requests="forward"  # (string, init-time) default = 'forward' : What to do with snoop requests from downstream.  The options are to 'forward', 'terminate' or 'handle'.  NOTE that currently the snoop request addresses are _not_ translated and so if your device alters the address translation then you will almost certainly want to 'terminate'.
cpu.impdef_regs_and_unpred_from_implementation=""     # (string, init-time) default = ''       : Configure implementation defined registers and unpredictable behaviour to match the specified implementation. Requires a license for the selected implementation model. Use ARM_Cortex-A<num> or ARM_<codename> for licensed pre-release cores.
cpu.has_el2=1                                         # (bool  , init-time) default = '1'      : Implements EL2
cpu.has_el3=1                                         # (bool  , init-time) default = '1'      : Implements EL3
cpu.max_32bit_el=0x3                                  # (int   , init-time) default = '0x3'    : Maximum exception level supporting AArch32 modes. : [0xFFFFFFFFFFFFFFFF..0x3]
cpu.has_aarch64=1                                     # (bool  , init-time) default = '1'      : All implemented exception levels can run in AArch64
cpu.has_supersections=1                               # (bool  , init-time) default = '1'      : Whether VMSAv8-32 supersection to support more than 32-bit PA using short descriptor is implemented.
cpu.rmr_always_implemented=0                          # (bool  , init-time) default = '0'      : Always implement RMR_ELx, RMR, or HRMR at the highest implemented exception level, even if that exception level cannot use both AArch32 and AArch64.
cpu.el0_el1_only_non_secure=0                         # (bool  , init-time) default = '0'      : Secure/non-secure state if EL2 and EL3 are not implemented.  0, secure.  1, non-secure.
cpu.PA_SIZE=0x28                                      # (int   , init-time) default = '0x28'   : Physical address range supported.  For ARMv8.0 and ARMv8.1 this is limited to 48 bits. : [0x20..0x34]
cpu.mvbar_reset_is_rvbar=1                            # (bool  , init-time) default = '1'      : If true then the reset value of MVBAR is RVBAR, if false the reset value is UNKNOWN.
cpu.has_aarch32_hpd=0                                 # (bool  , init-time) default = '0'      : If true then hierarchical permission disable is supported in AArch32
cpu.has_actlr2=0                                      # (bool  , init-time) default = '0'      : If true ACLTR2 exists and ACTLR2(NS) is aliased to ACTLR_EL1[63:32]
cpu.has_statistical_profiling=1                       # (bool  , init-time) default = '1'      : Whether Statistical Based Profiling is implemented
cpu.statistical_profiling_recommended_min_sampling=0x100  # (int   , init-time) default = '0x100'  : Statistical profiling recommended minimum sampling interval : [0x100..0x1000]
cpu.statistical_profiling_buffer_alignment=0x1        # (int   , init-time) default = '0x1'    : Statistical profiling alignment constraint for sample buffer : [0x1..0x800]
cpu.statistical_profiling_random_interval_is_separate=0  # (bool  , init-time) default = '0'      : Statistical profiling random interval gets added to the main timer interval(false) or (true) runs as separate timer
cpu.memory.acp.AxCACHE_mask=0x0                       # (int   , init-time) default = '0x0'    : Used with memory.acp.AxCACHE_pattern to define which memory types the ACP port accepts. All transactions which do not satisfy (AxCACHE & mask) == pattern will abort. : [0x0..0xF]
cpu.memory.acp.AxCACHE_pattern=0x0                    # (int   , init-time) default = '0x0'    : Used with memory.acp.AxCACHE_mask to define which memory types the ACP port accepts. All transactions which do not satisfy (AxCACHE & mask) == pattern will abort. : [0x0..0xF]
cpu.has_lrcpc=0                                       # (bool  , init-time) default = '0'      : If true then it support the RCpc feature (ARMv8.3)
cpu.has_arm_v8-1=0                                    # (bool  , init-time) default = '0'      : Implement the ARMv8.1 Extension.
cpu.has_arm_v8-2=0                                    # (bool  , init-time) default = '0'      : Implement the ARMv8.2 Extension.
cpu.has_arm_v8-3=0                                    # (bool  , init-time) default = '0'      : Implement the ARMv8.3 Extension.
cpu.has_arm_v8-4=0                                    # (bool  , init-time) default = '0'      : Implement the ARMv8.4 Extension. This feature is incomplete and under development.
cpu.has_arm_v8-5=0                                    # (bool  , init-time) default = '0'      : Implement the ARMv8.5 Extension. This feature is incomplete and under development.
cpu.num_loregions=0x0                                 # (int   , init-time) default = '0x0'    : Number of Limited Ordering Regions implemented excluding background region (if ARM v8.1 extensions are implemented) : [0x0..0xFF]
cpu.num_loregion_descriptors=0x0                      # (int   , init-time) default = '0x0'    : Number of Limited Ordering Region descriptors implemented (if ARM v8.1 extensions are implemented) : [0x0..0xFF]
cpu.ext_abort_normal_cacheable_read_ras_type=0x0      # (int   , init-time) default = '0x0'    : External Aborts are reported as RAS error type specified in this param. Values: 0 = NONE, 1 = UC, 2 = UEU, 3 = UEO , 4 = UER, 5 = CE. : [0x0..0x5]
cpu.ext_abort_normal_wt_cacheable_read_ras_type=0xFFFFFFFFFFFFFFFF  # (int   , init-time) default = '0xFFFFFFFFFFFFFFFF' : External Aborts are reported as RAS error type specified in this param. Values: -1 = Same as ext_abort_normal_cacheable_read_ras_type, 0 = NONE, 1 = UC, 2 = UEU, 3 = UEO , 4 = UER, 5 = CE. : [0xFFFFFFFFFFFFFFFF..0x5]
cpu.ext_abort_normal_noncacheable_read_ras_type=0x0   # (int   , init-time) default = '0x0'    : External Aborts are reported as RAS error type specified in this param. Values: 0 = NONE, 1 = UC, 2 = UEU, 3 = UEO , 4 = UER, 5 = CE. : [0x0..0x5]
cpu.ext_abort_device_read_ras_type=0x0                # (int   , init-time) default = '0x0'    : External Aborts are reported as RAS error type specified in this param. Values: 0 = NONE, 1 = UC, 2 = UEU, 3 = UEO , 4 = UER, 5 = CE. : [0x0..0x5]
cpu.ext_abort_device_nGRE_read_ras_type=0xFFFFFFFFFFFFFFFF  # (int   , init-time) default = '0xFFFFFFFFFFFFFFFF' : External Aborts are reported as RAS error type specified in this param. Values: -1 = Same as ext_abort_device_read_ras_type, 0 = NONE, 1 = UC, 2 = UEU, 3 = UEO , 4 = UER, 5 = CE. : [0xFFFFFFFFFFFFFFFF..0x5]
cpu.ext_abort_device_GRE_read_ras_type=0xFFFFFFFFFFFFFFFF  # (int   , init-time) default = '0xFFFFFFFFFFFFFFFF' : External Aborts are reported as RAS error type specified in this param. Values: -1 = Same as ext_abort_device_read_ras_type, 0 = NONE, 1 = UC, 2 = UEU, 3 = UEO , 4 = UER, 5 = CE. : [0xFFFFFFFFFFFFFFFF..0x5]
cpu.ext_abort_so_read_ras_type=0x0                    # (int   , init-time) default = '0x0'    : External Aborts are reported as RAS error type specified in this param. Values: 0 = NONE, 1 = UC, 2 = UEU, 3 = UEO , 4 = UER, 5 = CE. : [0x0..0x5]
cpu.ext_abort_normal_cacheable_write_ras_type=0x0     # (int   , init-time) default = '0x0'    : External Aborts are reported as RAS error type specified in this param. Values: 0 = NONE, 1 = UC, 2 = UEU, 3 = UEO , 4 = UER, 5 = CE. : [0x0..0x5]
cpu.ext_abort_normal_wt_cacheable_write_ras_type=0xFFFFFFFFFFFFFFFF  # (int   , init-time) default = '0xFFFFFFFFFFFFFFFF' : External Aborts are reported as RAS error type specified in this param. Values: -1 = Same as ext_abort_normal_cacheable_write_ras_type, 0 = NONE, 1 = UC, 2 = UEU, 3 = UEO , 4 = UER, 5 = CE. : [0xFFFFFFFFFFFFFFFF..0x5]
cpu.ext_abort_normal_noncacheable_write_ras_type=0x0  # (int   , init-time) default = '0x0'    : External Aborts are reported as RAS error type specified in this param. Values: 0 = NONE, 1 = UC, 2 = UEU, 3 = UEO , 4 = UER, 5 = CE. : [0x0..0x5]
cpu.ext_abort_device_write_ras_type=0x0               # (int   , init-time) default = '0x0'    : External Aborts are reported as RAS error type specified in this param. Values: 0 = NONE, 1 = UC, 2 = UEU, 3 = UEO , 4 = UER, 5 = CE. : [0x0..0x5]
cpu.ext_abort_device_nGRE_write_ras_type=0xFFFFFFFFFFFFFFFF  # (int   , init-time) default = '0xFFFFFFFFFFFFFFFF' : External Aborts are reported as RAS error type specified in this param. Values: -1 = Same as ext_abort_device_write_ras_type, 0 = NONE, 1 = UC, 2 = UEU, 3 = UEO , 4 = UER, 5 = CE. : [0xFFFFFFFFFFFFFFFF..0x5]
cpu.ext_abort_device_GRE_write_ras_type=0xFFFFFFFFFFFFFFFF  # (int   , init-time) default = '0xFFFFFFFFFFFFFFFF' : External Aborts are reported as RAS error type specified in this param. Values: -1 = Same as ext_abort_device_write_ras_type, 0 = NONE, 1 = UC, 2 = UEU, 3 = UEO , 4 = UER, 5 = CE. : [0xFFFFFFFFFFFFFFFF..0x5]
cpu.ext_abort_so_write_ras_type=0x0                   # (int   , init-time) default = '0x0'    : External Aborts are reported as RAS error type specified in this param. Values: 0 = NONE, 1 = UC, 2 = UEU, 3 = UEO , 4 = UER, 5 = CE. : [0x0..0x5]
cpu.ext_abort_ttw_cacheable_read_ras_type=0x0         # (int   , init-time) default = '0x0'    : External Aborts are reported as RAS error type specified in this param. Values: 0 = NONE, 1 = UC, 2 = UEU, 3 = UEO , 4 = UER, 5 = CE. : [0x0..0x5]
cpu.ext_abort_ttw_wt_cacheable_read_ras_type=0xFFFFFFFFFFFFFFFF  # (int   , init-time) default = '0xFFFFFFFFFFFFFFFF' : External Aborts are reported as RAS error type specified in this param. Values: -1 = Same as ext_abort_ttw_cacheable_read_ras_type, 0 = NONE, 1 = UC, 2 = UEU, 3 = UEO , 4 = UER, 5 = CE. : [0xFFFFFFFFFFFFFFFF..0x5]
cpu.ext_abort_ttw_noncacheable_read_ras_type=0x0      # (int   , init-time) default = '0x0'    : External Aborts are reported as RAS error type specified in this param. Values: 0 = NONE, 1 = UC, 2 = UEU, 3 = UEO , 4 = UER, 5 = CE. : [0x0..0x5]
cpu.ext_abort_prefetch_ras_type=0x0                   # (int   , init-time) default = '0x0'    : External Aborts are reported as RAS error type specified in this param. Values: 0 = NONE, 1 = UC, 2 = UEU, 3 = UEO , 4 = UER, 5 = CE. : [0x0..0x5]
cpu.ext_abort_normal_wt_cacheable_prefetch_ras_type=0xFFFFFFFFFFFFFFFF  # (int   , init-time) default = '0xFFFFFFFFFFFFFFFF' : External Aborts are reported as RAS error type specified in this param. Values: -1 = Same as ext_abort_prefetch_ras_type, 0 = NONE, 1 = UC, 2 = UEU, 3 = UEO , 4 = UER, 5 = CE. : [0xFFFFFFFFFFFFFFFF..0x5]
cpu.ext_abort_normal_noncacheable_prefetch_ras_type=0xFFFFFFFFFFFFFFFF  # (int   , init-time) default = '0xFFFFFFFFFFFFFFFF' : External Aborts are reported as RAS error type specified in this param. Values: -1 = Same as ext_abort_prefetch_ras_type, 0 = NONE, 1 = UC, 2 = UEU, 3 = UEO , 4 = UER, 5 = CE. : [0xFFFFFFFFFFFFFFFF..0x5]
cpu.ext_abort_device_prefetch_ras_type=0xFFFFFFFFFFFFFFFF  # (int   , init-time) default = '0xFFFFFFFFFFFFFFFF' : External Aborts are reported as RAS error type specified in this param. Values: -1 = Same as ext_abort_prefetch_ras_type, 0 = NONE, 1 = UC, 2 = UEU, 3 = UEO , 4 = UER, 5 = CE. : [0xFFFFFFFFFFFFFFFF..0x5]
cpu.ext_abort_device_nGRE_prefetch_ras_type=0xFFFFFFFFFFFFFFFF  # (int   , init-time) default = '0xFFFFFFFFFFFFFFFF' : External Aborts are reported as RAS error type specified in this param. Values: -1 = Same as ext_abort_prefetch_ras_type, 0 = NONE, 1 = UC, 2 = UEU, 3 = UEO , 4 = UER, 5 = CE. : [0xFFFFFFFFFFFFFFFF..0x5]
cpu.ext_abort_device_GRE_prefetch_ras_type=0xFFFFFFFFFFFFFFFF  # (int   , init-time) default = '0xFFFFFFFFFFFFFFFF' : External Aborts are reported as RAS error type specified in this param. Values: -1 = Same as ext_abort_prefetch_ras_type, 0 = NONE, 1 = UC, 2 = UEU, 3 = UEO , 4 = UER, 5 = CE. : [0xFFFFFFFFFFFFFFFF..0x5]
cpu.ext_abort_so_prefetch_ras_type=0xFFFFFFFFFFFFFFFF  # (int   , init-time) default = '0xFFFFFFFFFFFFFFFF' : External Aborts are reported as RAS error type specified in this param. Values: -1 = Same as ext_abort_prefetch_ras_type, 0 = NONE, 1 = UC, 2 = UEU, 3 = UEO , 4 = UER, 5 = CE. : [0xFFFFFFFFFFFFFFFF..0x5]
cpu.ext_abort_normal_cacheable_read_ras_index=0x0     # (int   , init-time) default = '0x0'    : External Aborts are reported in RAS record index specified in this param. Values: Valid indices in range [0, number_of_error_records). : [0x0..0xFFFE]
cpu.ext_abort_normal_wt_cacheable_read_ras_index=0xFFFFFFFFFFFFFFFF  # (int   , init-time) default = '0xFFFFFFFFFFFFFFFF' : External Aborts are reported in RAS record index specified in this param. Values: -1 = Same as ext_abort_normal_cacheable_read_ras_index, Valid indices in range [0, number_of_error_records). : [0xFFFFFFFFFFFFFFFF..0xFFFE]
cpu.ext_abort_normal_noncacheable_read_ras_index=0x0  # (int   , init-time) default = '0x0'    : External Aborts are reported in RAS record index specified in this param. Values: Valid indices in range [0, number_of_error_records). : [0x0..0xFFFE]
cpu.ext_abort_device_read_ras_index=0x0               # (int   , init-time) default = '0x0'    : External Aborts are reported in RAS record index specified in this param. Values: Valid indices in range [0, number_of_error_records). : [0x0..0xFFFE]
cpu.ext_abort_device_nGRE_read_ras_index=0xFFFFFFFFFFFFFFFF  # (int   , init-time) default = '0xFFFFFFFFFFFFFFFF' : External Aborts are reported in RAS record index specified in this param. Values: -1 = Same as ext_abort_device_read_ras_index, Valid indices in range [0, number_of_error_records). : [0xFFFFFFFFFFFFFFFF..0xFFFE]
cpu.ext_abort_device_GRE_read_ras_index=0xFFFFFFFFFFFFFFFF  # (int   , init-time) default = '0xFFFFFFFFFFFFFFFF' : External Aborts are reported in RAS record index specified in this param. Values: -1 = Same as ext_abort_device_read_ras_index, Valid indices in range [0, number_of_error_records). : [0xFFFFFFFFFFFFFFFF..0xFFFE]
cpu.ext_abort_so_read_ras_index=0x0                   # (int   , init-time) default = '0x0'    : External Aborts are reported in RAS record index specified in this param. Values: Valid indices in range [0, number_of_error_records). : [0x0..0xFFFE]
cpu.ext_abort_normal_cacheable_write_ras_index=0x0    # (int   , init-time) default = '0x0'    : External Aborts are reported in RAS record index specified in this param. Values: Valid indices in range [0, number_of_error_records). : [0x0..0xFFFE]
cpu.ext_abort_normal_wt_cacheable_write_ras_index=0xFFFFFFFFFFFFFFFF  # (int   , init-time) default = '0xFFFFFFFFFFFFFFFF' : External Aborts are reported in RAS record index specified in this param. Values: -1 = Same as ext_abort_normal_cacheable_write_ras_index, Valid indices in range [0, number_of_error_records). : [0xFFFFFFFFFFFFFFFF..0xFFFE]
cpu.ext_abort_normal_noncacheable_write_ras_index=0x0  # (int   , init-time) default = '0x0'    : External Aborts are reported in RAS record index specified in this param. Values: Valid indices in range [0, number_of_error_records). : [0x0..0xFFFE]
cpu.ext_abort_device_write_ras_index=0x0              # (int   , init-time) default = '0x0'    : External Aborts are reported in RAS record index specified in this param. Values: Valid indices in range [0, number_of_error_records). : [0x0..0xFFFE]
cpu.ext_abort_device_nGRE_write_ras_index=0xFFFFFFFFFFFFFFFF  # (int   , init-time) default = '0xFFFFFFFFFFFFFFFF' : External Aborts are reported in RAS record index specified in this param. Values: -1 = Same as ext_abort_device_write_ras_index, Valid indices in range [0, number_of_error_records). : [0xFFFFFFFFFFFFFFFF..0xFFFE]
cpu.ext_abort_device_GRE_write_ras_index=0xFFFFFFFFFFFFFFFF  # (int   , init-time) default = '0xFFFFFFFFFFFFFFFF' : External Aborts are reported in RAS record index specified in this param. Values: -1 = Same as ext_abort_device_write_ras_index, Valid indices in range [0, number_of_error_records). : [0xFFFFFFFFFFFFFFFF..0xFFFE]
cpu.ext_abort_so_write_ras_index=0x0                  # (int   , init-time) default = '0x0'    : External Aborts are reported in RAS record index specified in this param. Values: Valid indices in range [0, number_of_error_records). : [0x0..0xFFFE]
cpu.ext_abort_ttw_cacheable_read_ras_index=0x0        # (int   , init-time) default = '0x0'    : External Aborts are reported in RAS record index specified in this param. Values: Valid indices in range [0, number_of_error_records). : [0x0..0xFFFE]
cpu.ext_abort_ttw_wt_cacheable_read_ras_index=0xFFFFFFFFFFFFFFFF  # (int   , init-time) default = '0xFFFFFFFFFFFFFFFF' : External Aborts are reported in RAS record index specified in this param. Values: -1 = Same as ext_abort_ttw_cacheable_read_ras_index, Valid indices in range [0, number_of_error_records). : [0xFFFFFFFFFFFFFFFF..0xFFFE]
cpu.ext_abort_ttw_noncacheable_read_ras_index=0x0     # (int   , init-time) default = '0x0'    : External Aborts are reported in RAS record index specified in this param. Values: Valid indices in range [0, number_of_error_records). : [0x0..0xFFFE]
cpu.ext_abort_prefetch_ras_index=0x0                  # (int   , init-time) default = '0x0'    : External Aborts are reported in RAS record index specified in this param. Values: Valid indices in range [0, number_of_error_records). : [0x0..0xFFFE]
cpu.ext_abort_normal_wt_cacheable_prefetch_ras_index=0xFFFFFFFFFFFFFFFF  # (int   , init-time) default = '0xFFFFFFFFFFFFFFFF' : External Aborts are reported in RAS record index specified in this param. Values: -1 = Same as ext_abort_prefetch_ras_index, Valid indices in range [0, number_of_error_records). : [0xFFFFFFFFFFFFFFFF..0xFFFE]
cpu.ext_abort_normal_noncacheable_prefetch_ras_index=0xFFFFFFFFFFFFFFFF  # (int   , init-time) default = '0xFFFFFFFFFFFFFFFF' : External Aborts are reported in RAS record index specified in this param. Values: -1 = Same as ext_abort_prefetch_ras_index, Valid indices in range [0, number_of_error_records). : [0xFFFFFFFFFFFFFFFF..0xFFFE]
cpu.ext_abort_device_prefetch_ras_index=0xFFFFFFFFFFFFFFFF  # (int   , init-time) default = '0xFFFFFFFFFFFFFFFF' : External Aborts are reported in RAS record index specified in this param. Values: -1 = Same as ext_abort_prefetch_ras_index, Valid indices in range [0, number_of_error_records). : [0xFFFFFFFFFFFFFFFF..0xFFFE]
cpu.ext_abort_device_nGRE_prefetch_ras_index=0xFFFFFFFFFFFFFFFF  # (int   , init-time) default = '0xFFFFFFFFFFFFFFFF' : External Aborts are reported in RAS record index specified in this param. Values: -1 = Same as ext_abort_prefetch_ras_index, Valid indices in range [0, number_of_error_records). : [0xFFFFFFFFFFFFFFFF..0xFFFE]
cpu.ext_abort_device_GRE_prefetch_ras_index=0xFFFFFFFFFFFFFFFF  # (int   , init-time) default = '0xFFFFFFFFFFFFFFFF' : External Aborts are reported in RAS record index specified in this param. Values: -1 = Same as ext_abort_prefetch_ras_index, Valid indices in range [0, number_of_error_records). : [0xFFFFFFFFFFFFFFFF..0xFFFE]
cpu.ext_abort_so_prefetch_ras_index=0xFFFFFFFFFFFFFFFF  # (int   , init-time) default = '0xFFFFFFFFFFFFFFFF' : External Aborts are reported in RAS record index specified in this param. Values: -1 = Same as ext_abort_prefetch_ras_index, Valid indices in range [0, number_of_error_records). : [0xFFFFFFFFFFFFFFFF..0xFFFE]
cpu.ERXMISC0_mask=0x0                                 # (int   , init-time) default = '0x0'    : Write Mask for ERXMISC0 RAS Register : [0x0..0xFFFFFFFF]
cpu.number_of_error_records=0x0                       # (int   , init-time) default = '0x0'    : Cores Number of Error records supported for RAS : [0x0..0xFFFF]
cpu.error_record_feature_register=""                  # (string, init-time) default = ''       : RAS feature register values. An array of JSON objects. The JSON schema for the array is: [{"ED":0x0,"UI":0x0,"FI":0x0,"UE":0x0,"CFI":0x0,"CEC":0x0,"RP":0x0,"DUI":0x0,"CEO":0x0,"CI":0x0,"TS":0x0,"INJ":0x0,"Visibility":"Core"},other_feature_register_values]. Where ED,UI,FI, and UE have valid values betwn 0x0 - 0x3. CFI and DUI have valid values 0x0, 0x2 and 0x3. CEC has valid values 0x0,0x2 or 0x4. RP has valid value 0x0 or 0x1. CEO has valid values of 0x0 and 0x1. CI and TS has valid values of 0x0, 0x1 and 0x2. INJ has valid values 0x0 or 0x1. Visibility has valid values "Core" or "Cluster"
cpu.error_record_feature_register_json_file=""        # (string, init-time) default = ''       : File path to the RAS feature register values as JSON. The file uses the same format as the error_record_feature_register parameter value
cpu.has_ras_timestamp=0x0                             # (int   , init-time) default = '0x0'    : [DEPRECATED: Set TS field on first register in error_record_feature_register JSON instead] ARMv8.4 AArch64 RAS Timestamp register is implemented or not. 0 - No Timestamp is recorded, 1 - Generic Timer timestamp is recorded, 2 - IMP DEF timestamp is recorded. : [0x0..0x2]
cpu.has_ras_critical_error=0x0                        # (int   , init-time) default = '0x0'    : [DEPRECATED: Set CI field on first register in error_record_feature_register JSON instead] ARMv8.4 AArch64 RAS Critical Error is implemented or not. 0 - Feature Not Supported, 1 - Feature always enabled, 2 - Feature is controllable. : [0x0..0x2]
cpu.has_ras_fault_injection=0x0                       # (int   , init-time) default = '0x0'    : [DEPRECATED: Set INJ field on first register in error_record_feature_register JSON instead] Implement ARMv8.4 Standard Fault Injection mechanism.

Possible values of this parameter are:
  - 0, feature is not enabled.
  - 1, feature is implemented if ARMv8.4 is enabled.
  - 2, feature is implemented. : [0x0..0x2]
cpu.pseudo_fault_generation_feature_register=""       # (string, init-time) default = ''       : ARMv8.4 Standard Pseudo-fault generation feature register values. JSON schema for the parameter value is: [{"OF":false,"UC":false,"UEU":false,"UER":false,"UEO":false,"DE":false,"CE":0x0,"CI":false,"ER":false,"PN":false,"AV":false,"MV":false,"SYN":false,"R":false},other_psuedo-fault_generating_features_register_values]. Where OF, UC, UEU, UER, UEO, DE, CI, ER, PN, AV, MV, SYN, and R have valid false(NOT_SUPPORTED) and true(FEATURE_CONTROLLABLE), where CE can have 0(NOT_SUPPORTED), 1(NONSPECIFIC_CE_SUPPORTED) and 3(TRANSIENT_OR_PERSISTENT_CE_SUPPORTED). Effective only when ERXFR's INJ field allows it or has_ras_fault_injection is true.
cpu.has_ras_double_fault=0x1                          # (int   , init-time) default = '0x1'    : Implement ARMv8.4 RAS Doublt Fault Extension.

Possible values of this parameter are:
  - 1, feature is implemented if ARMv8.4 is enabled.
  - 2, feature is implemented. : [0x1..0x2]
cpu.has_mpam=0x0                                      # (int   , init-time) default = '0x0'    : Implement ARMv8.4 MPAM Registers and associated functionality.

Possible values of this parameter are:
  - 0, feature is not enabled.
  - 1, feature is implemented if ARMv8.4 is enabled.
  - 2, feature is implemented. : [0x0..0x2]
cpu.mpam_max_partid=0xFFFF                            # (int   , init-time) default = '0xFFFF' : MPAM Maximum PARTID Supported : [0x0..0xFFFF]
cpu.mpam_max_pmg=0xFF                                 # (int   , init-time) default = '0xFF'   : MPAM Maximum PMG Supported : [0x0..0xFF]
cpu.mpam_max_vpmr=0x0                                 # (int   , init-time) default = '0x0'    : MPAM Maximum VPMR Supported : [0x0..0x7]
cpu.mpam_has_hcr=0                                    # (bool  , init-time) default = '0'      : MPAM Whether MPAMIDR_EL1 HAS_HCR bit is set or clear
cpu.output_attributes="ExtendedID[62:55]=MPAM_PMG, ExtendedID[54:39]=MPAM_PARTID, ExtendedID[38]=MPAM_NS"  # (string, init-time) default = 'ExtendedID[62:55]=MPAM_PMG, ExtendedID[54:39]=MPAM_PARTID, ExtendedID[38]=MPAM_NS' : User-defined transform to be applied to bus attributes like MasterID, ExtendedID or UserFlags. Currently, only works for MPAM Attributes encoding into bus attributes.
cpu.stage2_tlb_size=0x0                               # (int   , init-time) default = '0x0'    : Number of stage2 only tlb entries. : [0x0..0xFFFFFFFF]
cpu.stage12_tlb_size=0x80                             # (int   , init-time) default = '0x80'   : Number of stage1+2 tlb entries. : [0x1..0xFFFFFFFF]
cpu.stage2_walkcache_size=0x0                         # (int   , init-time) default = '0x0'    : Number of stage2 only walk cache entries. : [0x0..0xFFFFFFFF]
cpu.spsr_el3_is_mapped_to_spsr_mon=1                  # (bool  , init-time) default = '1'      : Whether SPSR_EL3 is mapped to AArch32 register SPSR_mon
cpu.disable_sve_plugin=0                              # (bool  , init-time) default = '0'      : If true, SVE will not be implemented in this processor even if the plugin is loaded
cpu.ignore_access_flag_update_by_at_ops=0             # (bool  , init-time) default = '0'      : If true, AT operations do not update access flag
cpu.has_16bit_vmids=0x1                               # (int   , init-time) default = '0x1'    : Implement support for 16-bit VMIDs from ARMv8.1.

Possible values of this parameter are:
  - 0, feature is not enabled.
  - 1, feature is implemented if ARMv8.1 is enabled.
  - 2, feature is implemented. : [0x0..0x2]
cpu.hardware_translation_table_update_implemented=0x1  # (int   , init-time) default = '0x1'    : Implement hardware translation table updates from ARMv8.1.

Possible values of this parameter are:
  - 0, feature is not enabled.
  - 1, feature is implemented if ARMv8.1 is enabled.
  - 2, feature is implemented. : [0x0..0x2]
cpu.has_hardware_translation_table_update=0x2         # (int   , init-time) default = '0x2'    : Type of hardware translation table supported (when enabled by hardware_translation_table_update_implemented).  0, not implemented. 1, access bit updates implemented. 2, access bit updates and dirty bit mechanism implemented. : [0x0..0x2]
cpu.has_pstate_pan=0x1                                # (int   , init-time) default = '0x1'    : Implement the PSTATE.PAN (Privileged Access Never) control from ARMv8.1

Possible values of this parameter are:
  - 1, feature is implemented if ARMv8.1 is enabled.
  - 2, feature is implemented. : [0x1..0x2]
cpu.has_rounding_doubling_multiply_add_subtract=0x1   # (int   , init-time) default = '0x1'    : Implement the rounding doubling multiply add and subtract instructions from ARMv8.1

Possible values of this parameter are:
  - 1, feature is implemented if ARMv8.1 is enabled.
  - 2, feature is implemented. : [0x1..0x2]
cpu.trace_physical_registers_when_host_virtualisation_enabled=0x0  # (int   , init-time) default = '0x0'    : When host virtualisation is enabled, trace sysreg accesses to physical register accessed (0=disabled, 1=Trace only ELR/SPSR_EL1 as ELR/SPSR_EL2, 2=Trace all redirected registers as physical registers : [0x0..0x2]
cpu.has_common_not_private_translations=0x1           # (int   , init-time) default = '0x1'    : Implement the TTBRn_ELx.CnP (Common not Private) controls from ARMv8.2.

Possible values of this parameter are:
  - 1, feature is implemented if ARMv8.2 is enabled.
  - 2, feature is implemented. : [0x1..0x2]
cpu.has_stage2_xnx=0x1                                # (int   , init-time) default = '0x1'    : Implement the extended XN[1:0] stage 2 control from ARMv8.2.

Possible values of this parameter are:
  - 1, feature is implemented if ARMv8.2 is enabled.
  - 2, feature is implemented. : [0x1..0x2]
cpu.page_based_hardware_attributes=0x0                # (int   , init-time) default = '0x0'    : Implement the page based hardware attributes from ARMv8.2.  This parameter indicates which page table bits are available for hardware, where bits[3:0] correspond to PTE[62:59] and to TCR_ELx.HWUnyy. : [0x0..0xF]
cpu.has_pstate_uao=0x1                                # (int   , init-time) default = '0x1'    : Implement the PSTATE.UAO (User Access Override) control from ARMv8.2.

Possible values of this parameter are:
  - 1, feature is implemented if ARMv8.2 is enabled.
  - 2, feature is implemented. : [0x1..0x2]
cpu.has_ldm_stm_ordering_control=0x0                  # (int   , init-time) default = '0x0'    : Implement the SCTLR_ELx.LSMAOE (Load/Store Multiple Atomicity and Ordering Enable) and SCTLR_ELx,nTLSMD (no Trap Load/Store Multiple to Device) controls from ARMv8.2.

Possible values of this parameter are:
  - 0, feature is not enabled.
  - 1, feature is implemented if ARMv8.2 is enabled.
  - 2, feature is implemented. : [0x0..0x2]
cpu.has_fp16=0x1                                      # (int   , init-time) default = '0x1'    : Implement the half-precision floating-point data processing instructions from ARMv8.2.

Possible values of this parameter are:
  - 0, feature is not enabled.
  - 1, feature is implemented if ARMv8.2 is enabled.
  - 2, feature is implemented. : [0x0..0x2]
cpu.has_large_va=0x0                                  # (int   , init-time) default = '0x0'    : Implement support for the extended 52-bit virtual addresses from ARMv8.2.

Possible values of this parameter are:
  - 0, feature is not enabled.
  - 1, feature is implemented if ARMv8.2 is enabled.
  - 2, feature is implemented. : [0x0..0x2]
cpu.has_at_with_pan=0x1                               # (int   , init-time) default = '0x1'    : Implement new AT instructions with PAN support.

Possible values of this parameter are:
  - 1, feature is implemented if ARMv8.2 is enabled.
  - 2, feature is implemented. : [0x1..0x2]
cpu.tcr_ps_reserved_value_size=0x0                    # (int   , init-time) default = '0x0'    : Physical size treated when TCR.(I)PS is programmed with a reserved value. 0, 48 bits. 1, 52 bits. The parameter value is treated 0 if LPA is not supported. : [0x0..0x1]
cpu.has_ccidx=0                                       # (bool  , init-time) default = '0'      : Implement the ARMv8.3 CCSIDR Extension. Extending the ccsidr number of sets.
cpu.has_pointer_authentication=0x1                    # (int   , init-time) default = '0x1'    : Implement ARMv8.3 pointer authentication.

Possible values of this parameter are:
  - 1, feature is implemented if ARMv8.3 is enabled.
  - 2, feature is implemented. : [0x1..0x2]
cpu.has_generic_authentication=0x1                    # (int   , init-time) default = '0x1'    : Implement ARMv8.3 generic authentication.

Possible values of this parameter are:
  - 1, feature is implemented if ARMv8.3 is enabled.
  - 2, feature is implemented. : [0x1..0x2]
cpu.has_enhanced_pac=0                                # (bool  , init-time) default = '0'      : If pointer authentication is enabled then implement enhanced PAC.
cpu.has_nested_virtualization=0x1                     # (int   , init-time) default = '0x1'    : Implement ARMv8.3 nested virtualization.

Possible values of this parameter are:
  - 1, feature is implemented if ARMv8.3 is enabled.
  - 2, feature is implemented. : [0x1..0x2]
cpu.has_jscvt=0x1                                     # (int   , init-time) default = '0x1'    : Implement ARMv8.3 javascript Floating-point to Integer conversion instruction.

Possible values of this parameter are:
  - 1, feature is implemented if ARMv8.3 is enabled.
  - 2, feature is implemented. : [0x1..0x2]
cpu.has_complex_number=0x1                            # (int   , init-time) default = '0x1'    : Implement ARMv8.3 complex number support, Multiply Accumulate and Add instructions.

Possible values of this parameter are:
  - 1, feature is implemented if ARMv8.3 is enabled.
  - 2, feature is implemented. : [0x1..0x2]
cpu.use_rosetta_disass=0x1                            # (int   , init-time) default = '0x1'    : Use Rosetta disassembly library.

Possible values of this parameter are:
  - 0, feature is not enabled.
  - 1, feature is implemented if ARMv8.4 is enabled.
  - 2, feature is implemented. : [0x0..0x2]
cpu.has_v8_4_debug_extension=0x1                      # (int   , init-time) default = '0x1'    : Implement ARMv8.4 debug extensions

Possible values of this parameter are:
  - 1, feature is implemented if ARMv8.4 is enabled.
  - 2, feature is implemented. : [0x1..0x2]
cpu.has_fp16_fmlal=0x1                                # (int   , init-time) default = '0x1'    : Implement the New Floating Point Multiplication Variant (FP16 FMLAL, FMLSL) instructions from ARMv8.4. Only supported if has_fp16=0x1.

Possible values of this parameter are:
  - 1, feature is implemented if ARMv8.4 is enabled.
  - 2, feature is implemented. : [0x1..0x2]
cpu.has_dot_product=0x1                               # (int   , init-time) default = '0x1'    : Implement the dot product (UDOT, SDOT) instructions from ARMv8.4.

Possible values of this parameter are:
  - 1, feature is implemented if ARMv8.4 is enabled.
  - 2, feature is implemented. : [0x1..0x2]
cpu.has_small_page_table=0x1                          # (int   , init-time) default = '0x1'    : Implement small page table support which increases the maximum value of TxSZ field from ARMv8.4. Note: will be unimplemented only if both has_small_page_table=0x0 and has_secure_el2=0x0.

Possible values of this parameter are:
  - 0, feature is not enabled.
  - 1, feature is implemented if ARMv8.4 is enabled.
  - 2, feature is implemented. : [0x0..0x2]
cpu.has_cfinv_rmif_setf=0x1                           # (int   , init-time) default = '0x1'    : Implement flag manipulation (CFINV, RMIF, SETF8, SETF16) instructions from ARMv8.4.

Possible values of this parameter are:
  - 1, feature is implemented if ARMv8.4 is enabled.
  - 2, feature is implemented. : [0x1..0x2]
cpu.has_tlbi_to_outer_shareable=0x1                   # (int   , init-time) default = '0x1'    : Implement support for TLB Maintenance instructions that extend to the Outer Shareable domain (TLBI VAE1OS, etc) from ARMv8.4.

Possible values of this parameter are:
  - 1, feature is implemented if ARMv8.4 is enabled.
  - 2, feature is implemented. : [0x1..0x2]
cpu.has_tlbi_range=0x1                                # (int   , init-time) default = '0x1'    : Implement support for TLB Range Maintenance instructions (TLBI RVAE1, etc) from ARMv8.4.

Possible values of this parameter are:
  - 1, feature is implemented if ARMv8.4 is enabled.
  - 2, feature is implemented. : [0x1..0x2]
cpu.has_tlbi_ttl=0x1                                  # (int   , init-time) default = '0x1'    : Implement support for the TTL level hint in by-address TLB Maintenance instructions from ARMv8.4.

Possible values of this parameter are:
  - 1, feature is implemented if ARMv8.4 is enabled.
  - 2, feature is implemented. : [0x1..0x2]
cpu.has_amu=0x0                                       # (int   , init-time) default = '0x0'    : Implement activity monitor functionality from ARMv8.4.

Possible values of this parameter are:
  - 0, feature is not enabled.
  - 1, feature is implemented if ARMv8.4 is enabled.
  - 2, feature is implemented. : [0x0..0x2]
cpu.amu_has_external_interface=0x0                    # (int   , init-time) default = '0x0'    : Implement external memory-mapped access to system register of activity monitor unit from ARMv8.4.

Possible values of this parameter are:
  - 0, feature is not enabled.
  - 1, feature is implemented if ARMv8.4 is enabled.
  - 2, feature is implemented. : [0x0..0x2]
cpu.has_pstate_dit=0x1                                # (int   , init-time) default = '0x1'    : Implement timing insensitivity of data processing instructions from ARMv8.4.

Possible values of this parameter are:
  - 1, feature is implemented if ARMv8.4 is enabled.
  - 2, feature is implemented. : [0x1..0x2]
cpu.has_unaligned_single_copy_atomicity=0x1           # (int   , init-time) default = '0x1'    : Implement support for SCTLR_ELx.nAA from ARMv8.4, and A64 atomic, exclusive and acquire/release instructions accessing unaligned bytes inside a 16byte window will not generate alignment fault.

Possible values of this parameter are:
  - 1, feature is implemented if ARMv8.4 is enabled.
  - 2, feature is implemented. : [0x1..0x2]
cpu.has_ldapur_stlur=0x1                              # (int   , init-time) default = '0x1'    : Implement support for LDAPR and STLR instructions with immediate offsets from ARMv8.4.

Possible values of this parameter are:
  - 1, feature is implemented if ARMv8.4 is enabled.
  - 2, feature is implemented. : [0x1..0x2]
cpu.has_id_reg_read=0x1                               # (int   , init-time) default = '0x1'    : Implement read access to the ID registers  (ESR_ELx.EC=0x18)

Possible values of this parameter are:
  - 1, feature is implemented if ARMv8.4 is enabled.
  - 2, feature is implemented. : [0x1..0x2]
cpu.has_stage2_fwb=0x1                                # (int   , init-time) default = '0x1'    : Implement HCR_EL2.FWB, stage 2 control of memory types and cacheability

Possible values of this parameter are:
  - 1, feature is implemented if ARMv8.4 is enabled.
  - 2, feature is implemented. : [0x1..0x2]
cpu.has_v8_4_pmu_extension=0x1                        # (int   , init-time) default = '0x1'    : Implement PMU extension from ARMv8.4.

Possible values of this parameter are:
  - 1, feature is implemented if ARMv8.4 is enabled.
  - 2, feature is implemented. : [0x1..0x2]
cpu.has_vncr_el2=0x1                                  # (int   , init-time) default = '0x1'    : Implement support for nested virtualization enhancements from ARMv8.4.

Possible values of this parameter are:
  - 1, feature is implemented if ARMv8.4 is enabled.
  - 2, feature is implemented. : [0x1..0x2]
cpu.unpred_vncr_el2_ress_mismatch=0x0                 # (int   , init-time) default = '0x0'    : Constrained unpredictable choices when bits marked as RESS do not all have the same value for VNCR_EL2  - 0, Generating an EL2 translation regime translation abort on use of the VNCR_EL2 register
  - 1, Reserved sign exteneded bits of VNCR_EL2 are same as bit[52] or bit[48] based on if large VA is supported or not, for all purposes other than reading back the register
 : [0x0..0x1]
cpu.has_secure_el2=0x1                                # (int   , init-time) default = '0x1'    : Implement support for Secure EL2

Possible values of this parameter are:
  - 0, feature is not enabled.
  - 1, feature is implemented if ARMv8.4 is enabled.
  - 2, feature is implemented. : [0x0..0x2]
cpu.has_no_os_double_lock=0x0                         # (int   , init-time) default = '0x0'    : Do not implement the OS double-lock.

Possible values of this parameter are:
  - 0, feature is not enabled.
  - 1, feature is implemented if ARMv8.4 is enabled.
  - 2, feature is implemented. : [0x0..0x2]
cpu.has_self_hosted_trace_extension=0x1               # (int   , init-time) default = '0x1'    : Implement support for the Self-hosted Trace Extensions from ARMv8.4.

Possible values of this parameter are:
  - 0, feature is not enabled.
  - 1, feature is implemented if ARMv8.4 is enabled.
  - 2, feature is implemented. : [0x0..0x2]
cpu.changing_block_size_without_bbm_support=0x0       # (int   , init-time) default = '0x0'    : Level of support for changing block size without break-before-make. : [0x0..0x1]
cpu.fault_on_nT_bit_set=1                             # (bool  , init-time) default = '1'      : Whether block translation table entries with the nT bit set should always fault. Only applies when changing_block_size_without_bbm_support_level is 1 or higher.
cpu.delayed_dbgreg_between_secure_views=0x1           # (int   , init-time) default = '0x1'    : If delayed_dbgreg is enabled, whether the secure and nonsecure external views require explicit synchronization.

Possible values of this parameter are:
  - 0, feature is not enabled.
  - 1, feature is implemented if ARMv8.4 is enabled.
  - 2, feature is implemented. : [0x0..0x2]
cpu.independent_cache_control_traps=0x0               # (int   , init-time) default = '0x0'    : Implement Independent Cache Control traps from ARMv8.5. 0, NO_SUPPORT. 1, SUPPORTED_BUT_NOT_FOR_TLB_MAINTENANCE_INSTRUCTIONS. 2, FULL_SUPPORT. : [0x0..0x2]
cpu.has_branch_target_exception=0x0                   # (int   , init-time) default = '0x0'    : Implement Branch target identification mechanism from ARMv8.5.

Possible values of this parameter are:
  - 0, feature is not enabled.
  - 1, feature is implemented if ARMv8.5 is enabled.
  - 2, feature is implemented. : [0x0..0x2]
cpu.has_non_context_synchronizing_exception_controls=0x1  # (int   , init-time) default = '0x1'    : Implement cosmetic controls for whether exception entry and exit are context synchronizing events (SCTLR_ELx.{EIS,EOS}) from ARMv8.5.

Possible values of this parameter are:
  - 1, feature is implemented if ARMv8.5 is enabled.
  - 2, feature is implemented. : [0x1..0x2]
cpu.has_axflag_xaflag_frint=0x1                       # (int   , init-time) default = '0x1'    : Implement flag manipulation instructions (AXFlag, XAFlag, FRINT[32|64][X|Z]) from ARMv8.5.

Possible values of this parameter are:
  - 1, feature is implemented if ARMv8.5 is enabled.
  - 2, feature is implemented. : [0x1..0x2]
cpu.has_speculation_barrier_inst=0x1                  # (int   , init-time) default = '0x1'    : Implement speculation barrier instruction (SB) from ARMv8.5

Possible values of this parameter are:
  - 1, feature is implemented if ARMv8.5 is enabled.
  - 2, feature is implemented. : [0x1..0x2]
cpu.has_rndr=0x0                                      # (int   , init-time) default = '0x0'    : Implement random number instructions to read from RNDR and RNDRSS random number registers from ARMv8.5.

Possible values of this parameter are:
  - 0, feature is not enabled.
  - 1, feature is implemented if ARMv8.5 is enabled.
  - 2, feature is implemented. : [0x0..0x2]
cpu.tdosa_traps_osdlr_if_no_os_double_lock=1          # (bool  , init-time) default = '1'      : MDCR_EL*.TDOSA enables trap on OSDLR_EL1 and DBGOSDLR when OS double-lock is not implemented.
cpu.rndr_rndrrs_seed=0x0                              # (int   , init-time) default = '0x0'    : Initial seed for random engine used in RNDR register
cpu.memory_tagging_support_level=0x0                  # (int   , init-time) default = '0x0'    : Specify the memory tagging extension support level: 0, not implemented. 1, instructions and registers only are implemented. 2, implemented. : [0x0..0x2]
cpu.log2_of_memory_tags_in_bulk_access=0x2            # (int   , init-time) default = '0x2'    : Number of memory tags to be accessed by LDGV and STGV instructions : [0x0..0x4]
cpu.force_deterministic_irg_tag_generation=0          # (bool  , init-time) default = '0'      : Force the random tag generated by the IRG instruction when GCR_EL1.RRND=1 to equal RGSR_EL1.SEED[3:0] rather than a non-deterministic value
cpu.has_guest_translation_granule=0x1                 # (int   , init-time) default = '0x1'    : Implement mechanism for guest translation granule identification from ARMv8.5, ID values determined by stage1 granule configuration parameters

Possible values of this parameter are:
  - 1, feature is implemented if ARMv8.5 is enabled.
  - 2, feature is implemented. : [0x1..0x2]
cpu.has_e0pd=0x1                                      # (int   , init-time) default = '0x1'    : Implement ARMv8.5 feature to prevent unprivileged access to one half of the memory

Possible values of this parameter are:
  - 1, feature is implemented if ARMv8.5 is enabled.
  - 2, feature is implemented. : [0x1..0x2]
cpu.has_prediction_invalidation_instructions=0x1      # (int   , init-time) default = '0x1'    : Implement execution and data prediction invalidation from ARMv8.5

Possible values of this parameter are:
  - 1, feature is implemented if ARMv8.5 is enabled.
  - 2, feature is implemented. : [0x1..0x2]
cpu.has_cvadp_support=0x1                             # (int   , init-time) default = '0x1'    : Implement instruction to support cache clean by deep persistence (DC CVADP) from ARMv8.5, can be selected for core implemented on any arch version starting ARMv8.2

Possible values of this parameter are:
  - 1, feature is implemented if ARMv8.5 is enabled.
  - 2, feature is implemented. : [0x1..0x2]
cpu.has_data_alignment_flag=0x0                       # (int   , init-time) default = '0x0'    : Implement non-optimal misalignment flag for PMU/SPE from ARMv8.5

Possible values of this parameter are:
  - 0, feature is not enabled.
  - 1, feature is implemented if ARMv8.5 is enabled.
  - 2, feature is implemented. : [0x0..0x2]
cpu.optimal_alignment_size=0x1                        # (int   , init-time) default = '0x1'    : Alignment boundary which does not incur additional performance penalty from ARMv8.5.
  - 1, architectural misalignment is used to set PMU event LDST_ALIGN_LAT and SPE event E[11]
  - 2, access crossing 4 byte boundary is used to set PMU event LDST_ALIGN_LAT and SPE event E[11]
  - 3, access crossing 8 byte boundary is used to set PMU event LDST_ALIGN_LAT and SPE event E[11]
	...
  - 12, access crossing 4 Kbyte boundary is used to set PMU event LDST_ALIGN_LAT and SPE event E[11]
 : [0x1..0xC]
cpu.has_restriction_on_speculative_data_loaded=0x1    # (int   , init-time) default = '0x1'    : Implements the ARMv8.5 security feature (Restrictions on the effects of speculation)

Possible values of this parameter are:
  - 1, feature is implemented if ARMv8.5 is enabled.
  - 2, feature is implemented. : [0x1..0x2]
cpu.restriction_on_speculative_execution=0x0          # (int   , init-time) default = '0x0'    : Implements the ARMv8.5 security feature (Restrictions on the effects of speculation): 0: No disclosure whether branch targets trained in one context can affect speculative execution in a different context, 1: Branch targets trained in one context cannot affect speculative execution in a different hardware described context (SCXTNUM_ELx not supported), 2: Branch targets trained in one context cannot affect speculative execution in a different hardware described context (SCXTNUM_ELx supported) : [0x0..0x2]
cpu.pstate_ssbs_type=0x0                              # (int   , init-time) default = '0x0'    : Implement speculative store bypass safe feature from ARMv8.5. 0, Not supported. 1, Supported without MSR/MRS access to SSBS. 2, fully supported. : [0x0..0x2]
cpu.has_v8_5_debug_over_power_down=0x0                # (int   , init-time) default = '0x0'    : Implement ARMv8.5 Debug over powerdown

Possible values of this parameter are:
  - 0, feature is not enabled.
  - 1, feature is implemented if ARMv8.5 is enabled.
  - 2, feature is implemented. : [0x0..0x2]
cpu.ignore_DBGPRCR_CWRR=0                             # (bool  , init-time) default = '0'      : Ignore writes to the deprecated DBGPRCR.CWRR bit.
cpu.has_v8_5_pmu_extension=0x1                        # (int   , init-time) default = '0x1'    : Implement PMU extension from ARMv8.5.

Possible values of this parameter are:
  - 1, feature is implemented if ARMv8.5 is enabled.
  - 2, feature is implemented. : [0x1..0x2]
cpu.has_v8_5_spe_extension=0x1                        # (int   , init-time) default = '0x1'    : Implement SPE extension from ARMv8.5

Possible values of this parameter are:
  - 1, feature is implemented if ARMv8.5 is enabled.
  - 2, feature is implemented. : [0x1..0x2]
cpu.ras_frac=0x0                                      # (int   , init-time) default = '0x0'    : 0, No additional feature implemented. 1, Additional ERXMISC*, ERXPFG* registers and FaultInjection trap from RAS v1.1. implemented : [0x0..0x1]
cpu.use_mte_eac_02_instructions_encoding=1            # (bool  , init-time) default = '1'      : Use new MTE Intructions encoding since MTE spec EAC 0.2 in ARMv8.5.
cpu.l2cache-size=0x80000                              # (int   , init-time) default = '0x80000' : L2 Cache size in bytes. : [0x0..0x1000000]
cpu.l2cache-ways=0x10                                 # (int   , init-time) default = '0x10'   : L2 Cache number of ways (sets are implicit from size). : [0x1..0x40]
cpu.l2cache-hit_latency=0x0                           # (int   , run-time ) default = '0x0'    : L2 Cache timing annotation latency for hit.  Intended to model the tag-lookup time.  This is only used when l2cache-state_modelled=true.
cpu.l2cache-miss_latency=0x0                          # (int   , run-time ) default = '0x0'    : L2 Cache timing annotation latency for miss.  Intended to model the time for failed tag-lookup and allocation of intermediate buffers.  This is only used when l2cache-state_modelled=true.
cpu.l2cache-read_latency=0x0                          # (int   , run-time ) default = '0x0'    : L2 Cache timing annotation latency for read accesses given in ticks per byte accessed.l2cache-read_access_latency must be set to 0 for per-byte latencies to be applied.  This is in addition to the hit or miss latency, and intended to correspond to the time taken to transfer across the cache upstream bus. This is only used when l2cache-state_modelled=true.
cpu.l2cache-read_access_latency=0x0                   # (int   , run-time ) default = '0x0'    : L2 Cache timing annotation latency for read accesses given in ticks per access.  If this parameter is non-zero, per-access latencies will be used instead of per-byte even if l2cache-read_latency is set. This is in addition to the hit or miss latency, and intended to correspond to the time taken to transfer across the cache upstream bus, this is only used when l2cache-state_modelled=true.
cpu.l2cache-read_bus_width_in_bytes=0x8               # (int   , init-time) default = '0x8'    : L2 Cache read bus width in bytes used to calculate per-access timing annotations : [0x1..0xFFFFFFFF]
cpu.l2cache-write_latency=0x0                         # (int   , run-time ) default = '0x0'    : L2 Cache timing annotation latency for write accesses given in ticks per byte accessed. l2cache-write_access_latency must be set to 0 for per-byte latencies to be applied. This is only used when l2cache-state_modelled=true.
cpu.l2cache-write_access_latency=0x0                  # (int   , run-time ) default = '0x0'    : L2 Cache timing annotation latency for write accesses given in ticks per access. If this parameter is non-zero, per-access latencies will be used instead of per-byte even if l2cache-write_latency is set. This is only used when l2cache-state_modelled=true.
cpu.l2cache-write_bus_width_in_bytes=0x8              # (int   , init-time) default = '0x8'    : L2 Cache write bus width in bytes used to calculate per-access timing annotations : [0x1..0xFFFFFFFF]
cpu.l2cache-snoop_issue_latency=0x0                   # (int   , run-time ) default = '0x0'    : L2 Cache timing annotation latency for snoop accesses issued by this cache in total ticks. This is only used when dcache-state_modelled=true.
cpu.l2cache-snoop_data_transfer_latency=0x0           # (int   , run-time ) default = '0x0'    : L2 Cache timing annotation latency for received snoop accesses that perform a data transfer given in ticks per byte accessed. This is only used when dcache-state_modelled=true.
cpu.l2cache-maintenance_latency=0x0                   # (int   , run-time ) default = '0x0'    : L2 Cache timing annotation latency for cache maintenance operations given in total ticks. This is only used when dcache-state_modelled=true.
cpu.l3cache-mpamf.cpbm_width_s=0x0                    # (int   , init-time) default = '0x0'    : L3 Cache width of MPAM cache portion bitmap for secure accesses. If 0, the feature is not implemented, and all ways are available. : [0x0..0x20]
cpu.l3cache-mpamf.cpbm_width_ns=0x0                   # (int   , init-time) default = '0x0'    : L3 Cache width of MPAM cache portion bitmap for non-secure accesses. If 0, the feature is not implemented, and all ways are available. : [0x0..0x20]
cpu.l3cache-mpamf.cmax_width_s=0x0                    # (int   , init-time) default = '0x0'    : L3 Cache number of fractional bits in MPAM cache capacity partition control for secure accesses. Only the register interface  is implemented - the control is NOT FUNCTIONAL. : [0x0..0x10]
cpu.l3cache-mpamf.cmax_width_ns=0x0                   # (int   , init-time) default = '0x0'    : L3 Cache number of fractional bits in MPAM cache capacity partition control for non-secure accesses. Only the register interface  is implemented - the control is NOT FUNCTIONAL. : [0x0..0x10]
cpu.l3cache-mpamf.bwa_width_s=0x10                    # (int   , init-time) default = '0x10'   : L3 Cache width of MPAM bandwidth allocation fields for secure accesses. : [0x1..0x10]
cpu.l3cache-mpamf.bwa_width_ns=0x10                   # (int   , init-time) default = '0x10'   : L3 Cache width of MPAM bandwidth allocation fields for non-secure accesses. : [0x1..0x10]
cpu.l3cache-mpamf.has_prop_s=0                        # (bool  , init-time) default = '0'      : Enable memory bandwidth proportional stride control for secure accesses. Only the register interface  is implemented - the control is NOT FUNCTIONAL.
cpu.l3cache-mpamf.has_prop_ns=0                       # (bool  , init-time) default = '0'      : Enable memory bandwidth proportional stride control for non-secure accesses. Only the register interface  is implemented - the control is NOT FUNCTIONAL.
cpu.l3cache-mpamf.csu_num_mon_s=0x0                   # (int   , init-time) default = '0x0'    : L3 Cache number of MPAM cache storage usage monitors for secure accesses. : [0x0..0xFFFF]
cpu.l3cache-mpamf.csu_num_mon_ns=0x0                  # (int   , init-time) default = '0x0'    : L3 Cache number of MPAM cache storage usage monitors for non-secure accesses. : [0x0..0xFFFF]
cpu.is_uniprocessor=0                                 # (bool  , init-time) default = '0'      : Value for the U bit in MPIDR. true disables L1 cache coherency protocols
cpu.dic-spi_count=0x40                                # (int   , init-time) default = '0x40'   : Number of shared peripheral interrupts implemented : [0x0..0xE0]
cpu.has_16bit_asids=1                                 # (bool  , init-time) default = '1'      : Enable 16-bit ASIDs.
cpu.has_large_system_ext=0                            # (bool  , init-time) default = '0'      : Implement the ARMv8 Large System Extensions.
cpu.auxilliary_feature_register0=0x0                  # (int   , init-time) default = '0x0'    : Value of AFR0 ID register. : [0x0..0xFFFFFFFF]
cpu.clear_reg_top_eret=0x1                            # (int   , init-time) default = '0x1'    : Behaviour of the upper 32-bits of the Xn registers when changing between AArch32 state and AArch64 state.  0, upper 32-bits preserved for all registers.  1, upper 32-bits set to 0 for all accessible registers. 2,  upper 32-bits set to 0 for a random selection of accessible registers. 3, upper-32-bits set to 0 for registers touched in AArch32 : [0x0..0x3]
cpu.mixed_endian=0x1                                  # (int   , init-time) default = '0x1'    : Implement support for mixed endianness. 0, not supported. 1, supported at all exception levels. 2, supported at EL0 only. : [0x0..0x2]
cpu.ext_abort_normal_cacheable_read_is_sync=1         # (bool  , init-time) default = '1'      : Synchronous reporting of normal write-back cacheable-read external aborts
cpu.ext_abort_normal_cacheable_read_is_critical=0     # (bool  , init-time) default = '0'      : Critical reporting of normal write-back cacheable-read external aborts
cpu.ext_abort_normal_wt_cacheable_read_is_sync=0x2    # (int   , init-time) default = '0x2'    : Synchronous reporting of normal write-through read external aborts. 0, asynchronous. 1, synchronous. 2, same as ext_abort_normal_cacheable_read_is_sync. : [0x0..0x2]
cpu.ext_abort_normal_wt_cacheable_read_is_critical=0  # (bool  , init-time) default = '0'      : Critical reporting of normal write-through cacheable-read external aborts
cpu.ext_abort_normal_noncacheable_read_is_sync=1      # (bool  , init-time) default = '1'      : Synchronous reporting of normal noncacheable-read external aborts
cpu.ext_abort_normal_noncacheable_read_is_critical=0  # (bool  , init-time) default = '0'      : Critical reporting of normal noncacheable-read external aborts
cpu.ext_abort_device_read_is_sync=1                   # (bool  , init-time) default = '1'      : Synchronous reporting of device-nGnRE read external aborts
cpu.ext_abort_device_read_is_critical=0               # (bool  , init-time) default = '0'      : Critical reporting of device-nGnRE read external aborts
cpu.ext_abort_so_read_is_sync=1                       # (bool  , init-time) default = '1'      : Synchronous reporting of device-nGnRnE read external aborts
cpu.ext_abort_so_read_is_critical=0                   # (bool  , init-time) default = '0'      : Critical reporting of device-nGnRnE read external aborts
cpu.ext_abort_device_nGRE_read_is_sync=0x2            # (int   , init-time) default = '0x2'    : Synchronous reporting of device-nGRE read external aborts. 0, asynchronous. 1, synchronous. 2, same as ext_abort_device_read_is_sync. : [0x0..0x2]
cpu.ext_abort_device_nGRE_read_is_critical=0          # (bool  , init-time) default = '0'      : Critical reporting of device-nGRE read external aborts.
cpu.ext_abort_device_GRE_read_is_sync=0x2             # (int   , init-time) default = '0x2'    : Synchronous reporting of device-GRE read external aborts. 0, asynchronous. 1, synchronous. 2, same as ext_abort_device_read_is_sync. : [0x0..0x2]
cpu.ext_abort_device_GRE_read_is_critical=0           # (bool  , init-time) default = '0'      : Critical reporting of device-GRE read external aborts.
cpu.ext_abort_normal_cacheable_write_is_sync=0        # (bool  , init-time) default = '0'      : Synchronous reporting of normal write-back cacheable write external aborts
cpu.ext_abort_normal_cacheable_write_is_critical=0    # (bool  , init-time) default = '0'      : Critical reporting of normal write-back cacheable write external aborts
cpu.ext_abort_normal_wt_cacheable_write_is_sync=0x2   # (int   , init-time) default = '0x2'    : Synchronous reporting of normal write-through write external aborts. 0, asynchronous. 1, synchronous. 2, same as ext_abort_normal_cacheable_write_is_sync. : [0x0..0x2]
cpu.ext_abort_normal_wt_cacheable_write_is_critical=0  # (bool  , init-time) default = '0'      : Critical reporting of normal write-through write external aborts
cpu.ext_abort_normal_noncacheable_write_is_sync=0     # (bool  , init-time) default = '0'      : Synchronous reporting of normal noncacheable write external aborts
cpu.ext_abort_normal_noncacheable_write_is_critical=0  # (bool  , init-time) default = '0'      : Critical reporting of normal noncacheable write external aborts
cpu.ext_abort_device_write_is_sync=0                  # (bool  , init-time) default = '0'      : Synchronous reporting of device-nGnRE write external aborts
cpu.ext_abort_device_write_is_critical=0              # (bool  , init-time) default = '0'      : Critical reporting of device-nGnRE write external aborts
cpu.ext_abort_so_write_is_sync=1                      # (bool  , init-time) default = '1'      : Synchronous reporting of device-nGnRnE write external aborts
cpu.ext_abort_so_write_is_critical=0                  # (bool  , init-time) default = '0'      : Critical reporting of device-nGnRnE write external aborts
cpu.ext_abort_device_nGRE_write_is_sync=0x2           # (int   , init-time) default = '0x2'    : Synchronous reporting of device-nGRE write external aborts. 0, asynchronous. 1, synchronous. 2, same as ext_abort_device_write_is_sync. : [0x0..0x2]
cpu.ext_abort_device_nGRE_write_is_critical=0         # (bool  , init-time) default = '0'      : Critical reporting of device-nGRE write external aborts
cpu.ext_abort_device_GRE_write_is_sync=0x2            # (int   , init-time) default = '0x2'    : Synchronous reporting of device-GRE write external aborts. 0, asynchronous. 1, synchronous. 2, same as ext_abort_device_write_is_sync. : [0x0..0x2]
cpu.ext_abort_device_GRE_write_is_critical=0          # (bool  , init-time) default = '0'      : Critical reporting of device-GRE write external aborts
cpu.ext_abort_ttw_cacheable_read_is_sync=1            # (bool  , init-time) default = '1'      : Synchronous reporting of TTW cacheable read external aborts
cpu.ext_abort_ttw_cacheable_read_is_critical=0        # (bool  , init-time) default = '0'      : Critical reporting of TTW cacheable read external aborts
cpu.ext_abort_ttw_wt_cacheable_read_is_sync=0x2       # (int   , init-time) default = '0x2'    : Synchronous reporting of TTW write-through cacheable read external aborts. 0, asynchronous. 1, synchronous. 2, same as ext_abort_ttw_cacheable_read_is_sync. : [0x0..0x2]
cpu.ext_abort_ttw_wt_cacheable_read_is_critical=0     # (bool  , init-time) default = '0'      : Critical reporting of TTW write-through cacheable read external aborts
cpu.ext_abort_ttw_noncacheable_read_is_sync=1         # (bool  , init-time) default = '1'      : Synchronous reporting of TTW noncacheable read external aborts
cpu.ext_abort_ttw_noncacheable_read_is_critical=0     # (bool  , init-time) default = '0'      : Critical reporting of TTW noncacheable read external aborts
cpu.ext_abort_prefetch_is_sync=1                      # (bool  , init-time) default = '1'      : Behaviour of external aborts generated by normal writeback cacheable instruction fetches.  0, asynchronous abort.  1, synchronous abort.
cpu.ext_abort_prefetch_is_critical=0                  # (bool  , init-time) default = '0'      : Critical reporting of external aborts generated by normal writeback cacheable instruction fetches
cpu.ext_abort_prefetch_wt_cacheable_read_is_sync=0x2  # (int   , init-time) default = '0x2'    : Behaviour of external aborts generated by normal writethrough cacheable instruction fetches.  0, asynchronous abort.  1, synchronous abort. 2, same as ext_abort_prefetch_is_sync. : [0x0..0x2]
cpu.ext_abort_prefetch_wt_cacheable_read_is_critical=0  # (bool  , init-time) default = '0'      : Critical reporting of external aborts generated by normal writethrough cacheable instruction fetches
cpu.ext_abort_prefetch_noncacheable_read_is_sync=0x2  # (int   , init-time) default = '0x2'    : Behaviour of external aborts generated by normal noncacheable instruction fetches.  0, asynchronous abort.  1, synchronous abort. 2, same as ext_abort_prefetch_is_sync. : [0x0..0x2]
cpu.ext_abort_prefetch_noncacheable_read_is_critical=0  # (bool  , init-time) default = '0'      : Critical reporting of external aborts generated by normal noncacheable instruction fetches
cpu.ext_abort_prefetch_so_read_is_sync=0x2            # (int   , init-time) default = '0x2'    : Behaviour of external aborts generated by device=nGnRnE instruction fetches.  0, asynchronous abort.  1, synchronous abort. 2, same as ext_abort_prefetch_is_sync. : [0x0..0x2]
cpu.ext_abort_prefetch_so_read_is_critical=0          # (bool  , init-time) default = '0'      : Critical reporting of external aborts generated by device-nGnRnE instruction fetches
cpu.ext_abort_prefetch_device_read_is_sync=0x2        # (int   , init-time) default = '0x2'    : Behaviour of external aborts generated by device-nGnRE instruction fetches.  0, asynchronous abort.  1, synchronous abort. 2, same as ext_abort_prefetch_is_sync. : [0x0..0x2]
cpu.ext_abort_prefetch_device_read_is_critical=0      # (bool  , init-time) default = '0'      : Critical reporting of external aborts generated by device-nGnRE instruction fetches
cpu.ext_abort_prefetch_device_nGRE_read_is_sync=0x2   # (int   , init-time) default = '0x2'    : Behaviour of external aborts generated by device-nGRE instruction fetches.  0, asynchronous abort.  1, synchronous abort. 2, same as ext_abort_prefetch_is_sync. : [0x0..0x2]
cpu.ext_abort_prefetch_device_nGRE_read_is_critical=0  # (bool  , init-time) default = '0'      : Critical reporting of external aborts generated by device-nGRE instruction fetches
cpu.ext_abort_prefetch_device_GRE_read_is_sync=0x2    # (int   , init-time) default = '0x2'    : Behaviour of external aborts generated by device-GRE instruction fetches.  0, asynchronous abort.  1, synchronous abort. 2, same as ext_abort_prefetch_is_sync. : [0x0..0x2]
cpu.ext_abort_prefetch_device_GRE_read_is_critical=0  # (bool  , init-time) default = '0'      : Critical reporting of external aborts generated by device-GRE instruction fetches
cpu.ext_abort_fill_data=0xFDFDFDFCFCFDFDFD            # (int   , init-time) default = '0xFDFDFDFCFCFDFDFD' : Returned data, if external aborts are asynchronous
cpu.stage1_tlb_size=0x0                               # (int   , init-time) default = '0x0'    : Number of stage1 only tlb entries. : [0x0..0xFFFFFFFF]
cpu.instruction_tlb_size=0x0                          # (int   , init-time) default = '0x0'    : Number of stage1+2 itlb entries (or 0 for unified ITLB+DTLB) : [0x0..0xFFFFFFFF]
cpu.has_64k_granule=1                                 # (bool  , init-time) default = '1'      : Implement the 64k LPAE translation granule.
cpu.has_16k_granule=0                                 # (bool  , init-time) default = '0'      : Implement the 16k LPAE translation granule.
cpu.has_4k_granule=1                                  # (bool  , init-time) default = '1'      : Implement the 4k LPAE translation granule.
cpu.memory.l2_cache.is_inner_cacheable=1              # (bool  , init-time) default = '1'      : L2 cache obeys inner cacheable attributes (rather than outer cacheable attributes)
cpu.memory.l2_cache.is_inner_shareable=1              # (bool  , init-time) default = '1'      : L2 cache obeys inner shareable attributes (rather than outer sharaable attributes)
cpu.take_ccfail_undef=1                               # (bool  , init-time) default = '1'      : UNDEF exception is taken even if condition code check fails
cpu.take_ccfail_tsc_trap=0                            # (bool  , init-time) default = '0'      : When take_ccfail_undef=1 this prameter controls whether or not an SMC instruction that is trapped by HCR_EL2.TSC but fails its condition code check generates a trap to EL2.
cpu.tidcp_traps_el0_undef_imp_def=1                   # (bool  , init-time) default = '1'      : TIDCP has priority over UNDEF for accesses to IMPLEMENTATION DEFINED functionality from EL0
cpu.imp_def_functionality_behaviour=0x0               # (int   , init-time) default = '0x0'    : Behaviour of IMPLEMENTATION DEFINED registers and system instructions.  0, UNDEF.  1, RAZ/WI. : [0x0..0x1]
cpu.el0_can_access_imp_def_functionality=0            # (bool  , init-time) default = '0'      : If not made UNDEF by imp_def_functionality_behaviour, EL0 can access IMPLEMENTATION DEFINED registers and system instructions.
cpu.scheduler_mode=0x0                                # (int   , init-time) default = '0x0'    : Control the interleaving of instructions in this processor.  0, default long quantum. 1, low latency mode, short quantum and signal checking. 2, lock-breaking mode, long quantum with additional context switches near load-exclusive instructions. : [0x0..0x2]
cpu.cache-log2linelen=0x6                             # (int   , init-time) default = '0x6'    : Log2 of the cache line length in bytes. : [0x4..0x8]
cpu.icache-log2linelen=0x0                            # (int   , init-time) default = '0x0'    : If nonzero, Log2 of the instruction cache line length in bytes (valid values in range 4-8).  Otherwise the value of cache-log2linelen is used. : [0x0..0x8]
cpu.treat-dcache-invalidate-as-clean-invalidate=0     # (bool  , init-time) default = '0'      : Treat data cache invalidate operations as clean and invalidate.
cpu.dcimva_requires_s2_write_permissions=0            # (bool  , init-time) default = '0'      : Data-cache invalidate by MVA operations require stage 2 write permission (virtualised AArch32 guest).
cpu.BPIMVA_causes_translation_lookup=0                # (bool  , init-time) default = '0'      : Do a translation when BPIMVA instruction is executed (which may cause a translation fault).
cpu.watchpoint-log2secondary_restriction=0x0          # (int   , init-time) default = '0x0'    : log2 size of secondary restriction of FAR/EDWAR possible values on watchpoint hit for load/store operations. : [0x0..0x3F]
cpu.dcache-size=0x8000                                # (int   , init-time) default = '0x8000' : L1 D-Cache size in bytes. : [0x4000..0x100000]
cpu.dcache-ways=0x2                                   # (int   , init-time) default = '0x2'    : L1 D-Cache number of ways (sets are implicit from size). : [0x1..0x40]
cpu.icache-size=0x8000                                # (int   , init-time) default = '0x8000' : L1 I-Cache size in bytes. : [0x4000..0x100000]
cpu.icache-ways=0x2                                   # (int   , init-time) default = '0x2'    : L1 I-Cache number of ways (sets are implicit from size). : [0x1..0x40]
cpu.has_coherent_icache=0                             # (bool  , init-time) default = '0'      : Whether icache invalidation to the point of unification is required for instruction to data coherence. true - Invalidate operations not required
cpu.treat-dcache-cmos-to-pou-as-nop=0                 # (bool  , init-time) default = '0'      : Whether dcache invalidation to the point of unification is required for instruction to data coherence. true - Invalidate operations not required
cpu.unification-level=0x1                             # (int   , init-time) default = '0x1'    : Level of Unification Inner Shareable for the cache hierarchy : [0x0..0x4]
cpu.unification-uniprocessor-level=0x1                # (int   , init-time) default = '0x1'    : Level of Unification Uniprocessor for the cache hierarchy : [0x0..0x4]
cpu.cpi_mul=0x1                                       # (int   , run-time ) default = '0x1'    : Multiplier for calculating CPI (Cycles Per Instruction) : [0x1..0x7FFFFFFF]
cpu.cpi_div=0x1                                       # (int   , run-time ) default = '0x1'    : Divider for calculating CPI (Cycles Per Instruction) : [0x1..0x7FFFFFFF]
cpu.tlb_latency=0x0                                   # (int   , run-time ) default = '0x0'    : TLB latency for TA (Timing Annotation), expressed in simulation ticks
cpu.ptw_latency=0x0                                   # (int   , run-time ) default = '0x0'    : Page table walker latency for TA (Timing Annotation), expressed in simulation ticks
cpu.walk_cache_latency=0x0                            # (int   , run-time ) default = '0x0'    : Walk cache latency for TA (Timing Annotation), expressed in simulation ticks
cpu.icache-hit_latency=0x0                            # (int   , run-time ) default = '0x0'    : L1 I-Cache timing annotation latency for hit.  Intended to model the tag-lookup time.  This is only used when icache-state_modelled=true.
cpu.icache-miss_latency=0x0                           # (int   , run-time ) default = '0x0'    : L1 I-Cache timing annotation latency for miss.  Intended to model the time for failed tag-lookup and allocation of intermediate buffers.  This is only used when icache-state_modelled=true.
cpu.icache-read_latency=0x0                           # (int   , run-time ) default = '0x0'    : L1 I-Cache timing annotation latency for read accesses given in ticks per byte accessed.icache-read_access_latency must be set to 0 for per-byte latencies to be applied.  This is in addition to the hit or miss latency, and intended to correspond to the time taken to transfer across the cache upstream bus. This is only used when icache-state_modelled=true.
cpu.icache-read_access_latency=0x0                    # (int   , run-time ) default = '0x0'    : L1 I-Cache timing annotation latency for read accesses given in ticks per access (of size icache-read_bus_width_in_bytes).  If this parameter is non-zero, per-access latencies will be used instead of per-byte even if icache-read_latency is set. This is in addition to the hit or miss latency, and intended to correspond to the time taken to transfer across the cache upstream bus, this is only used when icache-state_modelled=true.
cpu.icache-read_bus_width_in_bytes=0x8                # (int   , init-time) default = '0x8'    : L1 I-Cache read bus width in bytes used to calculate per-access timing annotations : [0x1..0xFFFFFFFF]
cpu.icache-maintenance_latency=0x0                    # (int   , run-time ) default = '0x0'    : L1 I-Cache timing annotation latency for cache maintenance operations given in total ticks. This is only used when icache-state_modelled=true.
cpu.dcache-hit_latency=0x0                            # (int   , run-time ) default = '0x0'    : L1 D-Cache timing annotation latency for hit.  Intended to model the tag-lookup time.  This is only used when dcache-state_modelled=true.
cpu.dcache-miss_latency=0x0                           # (int   , run-time ) default = '0x0'    : L1 D-Cache timing annotation latency for miss.  Intended to model the time for failed tag-lookup and allocation of intermediate buffers.  This is only used when dcache-state_modelled=true.
cpu.dcache-read_latency=0x0                           # (int   , run-time ) default = '0x0'    : L1 D-Cache timing annotation latency for read accesses given in ticks per byte accessed.dcache-read_access_latency must be set to 0 for per-byte latencies to be applied.  This is in addition to the hit or miss latency, and intended to correspond to the time taken to transfer across the cache upstream bus. This is only used when dcache-state_modelled=true.
cpu.dcache-read_access_latency=0x0                    # (int   , run-time ) default = '0x0'    : L1 D-Cache timing annotation latency for read accesses given in ticks per access (of size dcache-read_bus_width_in_bytes).  If this parameter is non-zero, per-access latencies will be used instead of per-byte even if dcache-read_latency is set. This is in addition to the hit or miss latency, and intended to correspond to the time taken to transfer across the cache upstream bus, this is only used when dcache-state_modelled=true.
cpu.dcache-read_bus_width_in_bytes=0x8                # (int   , init-time) default = '0x8'    : L1 D-Cache read bus width in bytes used to calculate per-access timing annotations : [0x1..0xFFFFFFFF]
cpu.dcache-write_latency=0x0                          # (int   , run-time ) default = '0x0'    : L1 D-Cache timing annotation latency for write accesses given in ticks per byte accessed. dcache-write_access_latency must be set to 0 for per-byte latencies to be applied. This is only used when dcache-state_modelled=true.
cpu.dcache-write_access_latency=0x0                   # (int   , run-time ) default = '0x0'    : L1 D-Cache timing annotation latency for write accesses given in ticks per access (of size dcache-write_bus_width_in_bytes). If this parameter is non-zero, per-access latencies will be used instead of per-byte even if dcache-write_latency is set. This is only used when dcache-state_modelled=true.
cpu.dcache-write_bus_width_in_bytes=0x8               # (int   , init-time) default = '0x8'    : L1 D-Cache write bus width in bytes used to calculate per-access timing annotations : [0x1..0xFFFFFFFF]
cpu.dcache-snoop_data_transfer_latency=0x0            # (int   , run-time ) default = '0x0'    : L1 D-Cache timing annotation latency for received snoop accesses that perform a data transfer given in ticks per byte accessed. This is only used when dcache-state_modelled=true.
cpu.dcache-maintenance_latency=0x0                    # (int   , run-time ) default = '0x0'    : L1 D-Cache timing annotation latency for cache maintenance operations given in total ticks. This is only used when dcache-state_modelled=true.
cpu.icache-prefetch_enabled=0                         # (bool  , init-time) default = '0'      : Enable simulation of instruction cache prefetching. This is only used when icache-state_modelled=true.
cpu.icache-prefetch_level=0x0                         # (int   , init-time) default = '0x0'    : 0 based cache level at which instructions are pre-fetched. This is only used when icache-prefetch_enabled=true. : [0x0..0x7]
cpu.icache-nprefetch=0x1                              # (int   , init-time) default = '0x1'    : Number of next sequential instruction cache lines to prefetch. This is only used when icache-prefetch_enabled=true. : [0x0..0xFFFFFFFF]
cpu.dcache-prefetch_enabled=0                         # (bool  , init-time) default = '0'      : Enable simulation of data cache prefetching.  This is only used when dcache-state_modelled=true
cpu.CCSIDR-L1I_override=0x0                           # (int   , init-time) default = '0x0'    : If nonzero, override the value presented in CCSIDR for L1I (this is cosmetic and does not affect cache behaviour).
cpu.CCSIDR-L1D_override=0x0                           # (int   , init-time) default = '0x0'    : If nonzero, override the value presented in CCSIDR for L1D (this is cosmetic and does not affect cache behaviour).
cpu.CCSIDR-L2_override=0x0                            # (int   , init-time) default = '0x0'    : If nonzero, override the value presented in CCSIDR for L2 (this is cosmetic and does not affect cache behaviour).
cpu.CCSIDR-L3_override=0x0                            # (int   , init-time) default = '0x0'    : If nonzero, allow L3 selection in CSSELR and present this value in CCSIDR (this is cosmetic and does not affect cache behaviour).
cpu.MIDR=0x410FD0F0                                   # (int   , init-time) default = '0x410FD0F0' : Value of MIDR_EL1 register. : [0x0..0xFFFFFFFF]
cpu.DBGPIDR=0x0                                       # (int   , init-time) default = '0x0'    : If non-zero, override the Debug Peripheral Identification Register : [0x0..0xFFFFFFFFFF]
cpu.CTIPIDR=0x0                                       # (int   , init-time) default = '0x0'    : If non-zero, override the CTI Peripheral Identification Register : [0x0..0xFFFFFFFFFF]
cpu.PMUPIDR=0x0                                       # (int   , init-time) default = '0x0'    : If non-zero, override the PMU Peripheral Identification Register : [0x0..0xFFFFFFFFFF]
cpu.AIDR=0x0                                          # (int   , init-time) default = '0x0'    : Value of AIDR_EL1 register. : [0x0..0xFFFFFFFF]
cpu.use_tlb_contig_hint=0                             # (bool  , init-time) default = '0'      : Translation table entries with the contiguous hint bit set generate large TLB entries.
cpu.enable_tlb_contig_check=1                         # (bool  , init-time) default = '1'      : 
cpu.has_tlb_conflict_abort=0                          # (bool  , init-time) default = '0'      : Detected inconsistent TLB content generate aborts.
cpu.has_writebuffer=0                                 # (bool  , init-time) default = '0'      : Implement write accesses buffering before L1 cache. May affect ext_abort behaviour.
cpu.has_delayed_sysreg=0                              # (bool  , init-time) default = '0'      : Delay the functional effect of system register writes until ISB or implicit barrier.
cpu.has_delayed_dbgreg=0                              # (bool  , init-time) default = '0'      : Delay the functional effect of external debug register writes until ISB or implicit barrier.
cpu.has_delayed_ctireg=0                              # (bool  , init-time) default = '0'      : Delay the functional effect of CTI register writes until ISB or implicit barrier.
cpu.unpredictable_hvc_behaviour=0x0                   # (int   , init-time) default = '0x0'    : HVC unpredictable behaviour. 0, UNDEF. 1, NOP. : [0x0..0x1]
cpu.unpredictable_smc_behaviour=0x0                   # (int   , init-time) default = '0x0'    : SMC unpredictable behaviour. 0, UNDEF. 1, NOP. : [0x0..0x1]
cpu.cache_maintenance_hits_watchpoints=0              # (bool  , init-time) default = '0'      : DCIMVA operations executed in AArch32 modes hit watchpoints.
cpu.abort_execution_from_device_memory=0              # (bool  , init-time) default = '0'      : Execution from device memory generates a prefetch abort.
cpu.register_reset_data=0x0                           # (int   , init-time) default = '0x0'    : Data used to fill register bits when they become UNKNOWN at reset.
cpu.scramble_unknowns_at_reset=1                      # (bool  , init-time) default = '1'      : Will fill in unknown bits in registers at reset with register_reset_data
cpu.stage1_walkcache_size=0x0                         # (int   , init-time) default = '0x0'    : Number of stage1 only walk cache entries. : [0x0..0xFFFFFFFF]
cpu.apsr_read_restrict=0                              # (bool  , init-time) default = '0'      : At EL0, unknown bits of APSR are RAZ.
cpu.non_secure_vgic_alias_when_ns_only=0x0            # (int   , init-time) default = '0x0'    : If ! has_el3 and only non-secure side exists, then the normal position of the VGIC is a secure alias.  If this parameter is non-zero then in addition a non-secure alias of the VGIC will be placed at this position (aligned to 32 KB). : [0x0..0xFFFFFFFFFFFF]
cpu.warn_unpredictable_in_v7=0                        # (bool  , init-time) default = '0'      : 
cpu.exercise_stxr_fail=0                              # (bool  , init-time) default = '0'      : Reject a pseudo-random majority of exclusive store instructions
cpu.unpredictable_exclusive_abort_memtype=0x0         # (int   , init-time) default = '0x0'    : Cause MMU abort if exclusive access is not supported in certain memory type (0=exclusives allowed in all memory types, 1=exclusives abort in Device memory types, 2=exclusives abort in any type other than WB inner cacheable) : [0x0..0x2]
cpu.has_unsupported_exclusive_fault=1                 # (bool  , init-time) default = '1'      : Report unsupported exclusive access with Unsupported Exclusive fault status (otherwise use external abort)
cpu.has_synchronous_load_atomics=1                    # (bool  , init-time) default = '1'      : Report asynchronous abort due to unsupported load atomics as synchronous
cpu.has_synchronous_store_atomics=0                   # (bool  , init-time) default = '0'      : Report asynchronous abort due to unsupported store atomics as synchronous
cpu.unsupported_atomic_fault_type=0x0                 # (int   , init-time) default = '0x0'    : Type of fault reported on unsupported atomic access. 0 = external abort if any reported by interconnect, 1 = precise unsupported atomic fault, 2 = precise external abort. : [0x0..0x2]
cpu.delay_serror=0x0                                  # (int   , init-time) default = '0x0'    : Add a propagation delay of serror signal into the core : [0x0..0xFFFFFFFF]
cpu.pmu-num_counters=0x8                              # (int   , init-time) default = '0x8'    : Number of pmu counters implemented : [0x0..0x1F]
cpu.report_iside_cmo_ifsr=1                           # (bool  , init-time) default = '1'      : fault info for an iside cache maintenance operation is reported in the IFSR
cpu.trap_reserved_group3_id_regs=0                    # (bool  , init-time) default = '0'      : Whether setting HCR_EL2.TID3 traps reserved group3 id registers.
cpu.truncate_pc_on_illegal_exception_return_to_aarch32=1  # (bool  , init-time) default = '1'      : On Illegal ERET to AArch32, truncate PC to 32-bits
cpu.ADFSR-AIFSR-implemented=0                         # (bool  , init-time) default = '0'      : ADFSR and AIFSR are implemented
cpu.branch-predictor-clear-policy=0x2                 # (int   , init-time) default = '0x2'    : Set branch prediction policy as defined for MMFR1[31:28].  This does not change the behaviour of the branch predictor, only what is reported in MMFR1.BPred. : [0x0..0x4]
cpu.branch-predictor-supported-ops=0x1                # (int   , init-time) default = '0x1'    : Set branch prediction policy as defined for MMFR3[11:8].  This does not change the behaviour of the branch predictor, only what is reported in MMFR3.BPMaint. : [0x0..0x2]
cpu.hsr_uncond_cc=0                                   # (bool  , init-time) default = '0'      : Condition codes reported in HSR as AL if it passes
cpu.fpcr_short_vector_raz=0                           # (bool  , init-time) default = '0'      : FPSCR and FPCR fields LEN and STRIDE are hardwired to 0
cpu.treat_wfi_wfe_as_nop=0                            # (bool  , init-time) default = '0'      : If true, never go into wait state for WFI or WFE instructions.
cpu.treat_pld_as_nop=0                                # (bool  , init-time) default = '0'      : If true, treat PLD as NOP.
cpu.treat_pli_as_nop=0                                # (bool  , init-time) default = '0'      : If true, treat PLI as NOP.
cpu.itd_conditional_instructions_are_32bit=0          # (bool  , init-time) default = '0'      : When SCTLR_ELx.ITD=1, an IT instruction plus a T16 instruction are considered a single 32bit conditional instruction.
cpu.hcptr_tta_behaviour=0x2                           # (int   , init-time) default = '0x2'    : Behaviour of HCPTR.TTA when there is no CP14 ETM interface. 0, RAZ/WI. 1, RAO/WI. 2, stateful. : [0x0..0x2]
cpu.cpacr_trcdis_behaviour=0x2                        # (int   , init-time) default = '0x2'    : Behaviour of CPACR.TRCDIS/NSACR.NSTRCDIS when there is no CP14 ETM interface. 0, RAZ/WI. 2, implemented. : [0x0..0x2]
cpu.has_aarch32_dbgdidr_etc=1                         # (bool  , init-time) default = '1'      : DBGDIDR, DBGDRAR, DBGDSAR exist even if EL1 doesn't implement AArch32
cpu.DBGBCR_BT_applies_RES0_before_valid_check=1       # (bool  , init-time) default = '1'      : If true, RES0 behaviour is applied to DBGBCR(_EL1).BT before checking for reserved values for this field.
cpu.has_debug_rom=1                                   # (bool  , init-time) default = '1'      : If true, a debug ROM will be generated describing the cluster's debug components.
cpu.debug_rom_is_flat=0                               # (bool  , init-time) default = '0'      : If true, present a debug ROM table recommended by ARMv8 Debug Architecture.  Otherwise, use nested ROM tables.
cpu.debug_rom_is_class_9=0                            # (bool  , init-time) default = '0'      : If true, present a debug ROM table as a class 9 device.  Otherwise, use a class 1 ROM table.
cpu.advsimd_overread=0                                # (bool  , init-time) default = '0'      : AdvSIMD element load operations access all bytes of a 16-byte aligned window, even in Device memory
cpu.has_pmu=1                                         # (bool  , init-time) default = '1'      : Implement the optional Performance Monitors Extension.
cpu.pmu_has_chain_event=1                             # (bool  , init-time) default = '1'      : PMU (if present) implements event number 0x1e, CHAIN.
cpu.has_pc_sample_based_profiling=1                   # (bool  , init-time) default = '1'      : If true, pc sample-based profiling is enabled.
cpu.is_first_pcsr_sample_ignored=0                    # (bool  , init-time) default = '0'      : If true, First read of PMPCSR register after reset returns 0xFFFFFFFF
cpu.has_exception_trapping_form_of_vector_catch=1     # (bool  , init-time) default = '1'      : Implement the exception trapping form of vector catch debug event.
cpu.exception_catch_type=0x0                          # (int   , init-time) default = '0x0'    : Type of exception catch (ARMv8.0 - ARMv8.1 only). 0, exception trapping. 1, non-exception trapping, higher priority than step. 2, non-exception-trapping, lower priority than step. : [0x0..0x2]
cpu.hcr_swio_res1=0                                   # (bool  , init-time) default = '0'      : Whether HCR.SWIO and/or HCR_EL2.SWIO are RES1.
cpu.scr_nET_writeable=0                               # (bool  , init-time) default = '0'      : Whether SCR.nET is writeable. Writing to it is purely cosmetic (nET behavior not implemented)
cpu.dbgitr_buffer_size=0x0                            # (int   , init-time) default = '0x0'    : Number of instructions which can be bufferred before EDSCR.ITE is cleared : [0x0..0xFFFFFFFF]
cpu.force_align_pc=0                                  # (bool  , init-time) default = '0'      : UNPREDICTABLE branch to non-word-aligned address in ARM state is forced to be aligned
cpu.align_pc_on_debug_exit_to_aarch32=0               # (bool  , init-time) default = '0'      : Exit to AARCH32 state from debug state forces pc bit0 to 0
cpu.unpred_mrsmsr_protfailed_undef=0                  # (bool  , init-time) default = '0'      : UNPREDICTABLE register access (not accessible from current PL and security state) modeled as NOP when false and UNDEF when true
cpu.unpred_mrsmsr_currentlymapped_undef=0             # (bool  , init-time) default = '0'      : UNPREDICTABLE register access (accessible from current mode using different instruction) modeled as NOP when false and UNDEF when true
cpu.check_memory_attributes=1                         # (bool  , init-time) default = '1'      : Detect and report TLB use of conflicting memory attributes for views of the same physical address
cpu.unpred_tsize_aborts=0                             # (bool  , init-time) default = '0'      : Behaviour when TSize is out of range. 0, force into range. 1, translation fault, forces unpred_tsize_pamax_aborts to 1.
cpu.unpred_tsize_pamax_aborts=0                       # (bool  , init-time) default = '0'      : Behaviour when stage 2 TSize exceeds the physical address size (or 40bits, from AArch32). 0, force into range. 1, translation fault.  Ignored if unpred_tsize_aborts is 1.
cpu.has_far_not_valid=0                               # (bool  , init-time) default = '0'      : Implements FnV bit in ESR_ELx and xFSR, FAR not valid for synchronous external aborts.
cpu.exclusive_monitor_clear_on_strex_success=1        # (bool  , init-time) default = '1'      : Exclusive monitors in the cluster will be cleared when a strex succeeds.
cpu.exclusive_monitor_clear_on_strex_address_mismatch=1  # (bool  , init-time) default = '1'      : Exclusive monitors in the cluster will be cleared when a strex fails because the address does not match.
cpu.exclusive_monitor_clear_on_store_from_same_master=1  # (bool  , init-time) default = '1'      : Exclusive monitors in the cluster will be cleared by a store by the same master to the monitored address.
cpu.exclusive_monitor_clear_on_atomic_from_same_master=1  # (bool  , init-time) default = '1'      : Exclusive monitors in the cluster will be cleared by a atomic by the same master to the monitored address.
cpu.unpred_edscr_rw_unknown_bits_read_as_1=0          # (bool  , init-time) default = '0'      : Unknown(x) bits in RW field in EDSCR are read as 1 instead of 0.
cpu.mpidr_layout=0x0                                  # (int   , init-time) default = '0x0'    : Layout of MPIDR. 0 AFF0 is CPUID, 1 AFF1 is CPUID : [0x0..0x1]
cpu.supports_multi_threading=0                        # (bool  , init-time) default = '0'      : Sets the MPIDR.MT bit. Setting this to true hints the the cluster is multi-threading compatible
cpu.align_pc_on_illegal_exception_return_to_aarch32=1  # (bool  , init-time) default = '1'      : Align PC when performing an illegal exception return from AArch64 to AArch32.
cpu.has_itd=1                                         # (bool  , init-time) default = '1'      : Implement the optional IT disable feature.
cpu.has_edacr=1                                       # (bool  , init-time) default = '1'      : Implement EDACR register
cpu.unpred_load_single_reg_overlap_with_wb=0x0        # (int   , init-time) default = '0x0'    : Constrained unpredictable behaviours for single load with writeback(might impact certain load pair instructions) 0 Constraint_WBSUPPRESS, 1 Constraint_UNDEF, 2 Constraint_NOP : [0x0..0x2]
cpu.unpred_store_pair_and_single_reg_overlap_with_wb=0x0  # (int   , init-time) default = '0x0'    : Constrained unpredictable behaviours for pair and single store with writeback(doesn't cover store exclusive) 0 Constraint_NONE, 1 Constraint_UNDEF, 2 Constraint_NOP : [0x0..0x2]
cpu.unpred_store_exclusive_base_overlap=0x0           # (int   , init-time) default = '0x0'    : Constrained unpredictable behaviours for store exclusive when s==n. 0 Constraint_NONE, 1 Constraint_UNDEF, 2 Constraint_NOP : [0x0..0x2]
cpu.trace_has_sysreg_access=1                         # (bool  , init-time) default = '1'      : ETM trace registers support access via system registers
cpu.has_software_lock=1                               # (bool  , init-time) default = '1'      : Implement software lock in memory-mapped CTI, PMU, and external debug interfaces
cpu.has_ras=0x0                                       # (int   , init-time) default = '0x0'    : Implements the ARMv8 RAS Extension. 0 = NO_RAS, 1 = MINIMAL_RAS, 2 = FULL_RAS : [0x0..0x2]
cpu.edpfr_ras_unknown_bits_read_as_0=0                # (bool  , init-time) default = '0'      : If true then UNKNOWN bits in RAS field in EDPFR are read as 0
cpu.strex_fail_can_hit_watchpoint=0                   # (bool  , init-time) default = '0'      : If true, a strex fail can hit watchpoint
cpu.jidr_is_undef_at_el0=0                            # (bool  , init-time) default = '0'      : If true, JIDR register access is UNDEF at EL0
cpu.CTR-L1Ip-override=0x0                             # (int   , init-time) default = '0x0'    : If non-zero, override the L1Ip bits in CTR/CTR_EL0 system register. This does not change the behaviour of the cache, only what is present in the CTR register. : [0x0..0x3]
cpu.dcache-state_modelled=1                           # (bool  , init-time) default = '1'      : 
cpu.icache-state_modelled=1                           # (bool  , init-time) default = '1'      : 
cpu.PERIPHBASE=0x13080000                             # (int   , init-time) default = '0x13080000' : Base address of peripheral memory space : [0x0..0xFFFFFFFFFFFF]
cpu.l3cache-size=0x0                                  # (int   , init-time) default = '0x0'    : L3 Cache size in bytes. : [0x0..0x1000000]
cpu.l3cache-ways=0x10                                 # (int   , init-time) default = '0x10'   : L3 Cache number of ways (sets are implicit from size). : [0x1..0x40]
cpu.l3cache-hit_latency=0x0                           # (int   , run-time ) default = '0x0'    : L3 Cache timing annotation latency for hit.  Intended to model the tag-lookup time.  This is only used when l3cache-state_modelled=true.
cpu.l3cache-miss_latency=0x0                          # (int   , run-time ) default = '0x0'    : L3 Cache timing annotation latency for miss.  Intended to model the time for failed tag-lookup and allocation of intermediate buffers.  This is only used when l3cache-state_modelled=true.
cpu.l3cache-read_latency=0x0                          # (int   , run-time ) default = '0x0'    : L3 Cache timing annotation latency for read accesses given in ticks per byte accessed.l3cache-read_access_latency must be set to 0 for per-byte latencies to be applied.  This is in addition to the hit or miss latency, and intended to correspond to the time taken to transfer across the cache upstream bus. This is only used when l3cache-state_modelled=true.
cpu.l3cache-read_access_latency=0x0                   # (int   , run-time ) default = '0x0'    : L3 Cache timing annotation latency for read accesses given in ticks per access (of size l3cache-read_bus_width_in_bytes).  If this parameter is non-zero, per-access latencies will be used instead of per-byte even if l3cache-read_latency is set. This is in addition to the hit or miss latency, and intended to correspond to the time taken to transfer across the cache upstream bus, this is only used when l3cache-state_modelled=true.
cpu.l3cache-read_bus_width_in_bytes=0x8               # (int   , init-time) default = '0x8'    : L3 Cache read bus width in bytes used to calculate per-access timing annotations : [0x1..0xFFFFFFFF]
cpu.l3cache-write_latency=0x0                         # (int   , run-time ) default = '0x0'    : L3 Cache timing annotation latency for write accesses given in ticks per byte accessed. l3cache-write_access_latency must be set to 0 for per-byte latencies to be applied. This is only used when l3cache-state_modelled=true.
cpu.l3cache-write_access_latency=0x0                  # (int   , run-time ) default = '0x0'    : L3 Cache timing annotation latency for write accesses given in ticks per access (of size l3cache-write_bus_width_in_bytes). If this parameter is non-zero, per-access latencies will be used instead of per-byte even if l3cache-write_latency is set. This is only used when l3cache-state_modelled=true.
cpu.l3cache-write_bus_width_in_bytes=0x8              # (int   , init-time) default = '0x8'    : L3 Cache write bus width in bytes used to calculate per-access timing annotations : [0x1..0xFFFFFFFF]
cpu.l3cache-snoop_issue_latency=0x0                   # (int   , run-time ) default = '0x0'    : L3 Cache timing annotation latency for snoop accesses issued by this cache in total ticks. This is only used when dcache-state_modelled=true.
cpu.l3cache-snoop_data_transfer_latency=0x0           # (int   , run-time ) default = '0x0'    : L3 Cache timing annotation latency for received snoop accesses that perform a data transfer given in ticks per byte accessed. This is only used when dcache-state_modelled=true.
cpu.l3cache-maintenance_latency=0x0                   # (int   , run-time ) default = '0x0'    : L3 Cache timing annotation latency for cache maintenance operations given in total ticks. This is only used when dcache-state_modelled=true.
cpu.gicv3.STATUSR-implemented=1                       # (bool  , init-time) default = '1'      : If GICv3 CPU interface is being used, this determines whether the STATUS registers are implemented
cpu.gicv3.IIDR_base=0x43B                             # (int   , init-time) default = '0x43B'  : The base value for calculating the GICC_IIDR register value. : [0x0..0xFFFFFFFF]
cpu.gicv3.BPR-min=0x2                                 # (int   , init-time) default = '0x2'    : The minimum value for the GICC_BPR register (non-secure version will be 1 + this value). : [0x0..0x3]
cpu.gicv3.VBPR-min=0x2                                # (int   , init-time) default = '0x2'    : The minimum value for the GICV_BPR register (non-secure version will be 1 + this value). : [0x0..0x3]
cpu.gicv3.LR-count=0x10                               # (int   , init-time) default = '0x10'   : The number of implemented list registers. : [0x0..0x40]
cpu.gicv3.ignore-DIR-write-when-EOImode-not-set=1     # (bool  , init-time) default = '1'      : Ignore UNPREDICTABLE access to GICC_DIR register.
cpu.gicv3.virtual-lpi-support=1                       # (bool  , init-time) default = '1'      : When GICv3 is supported, indicates a cut down CPUIF interface with no support of VLPI (GICv3 only) when false
cpu.gicv3.suppress-virtual-enables-comms=1            # (bool  , init-time) default = '1'      : In GICv3 only mode, prevents the GIC CPUIF from communicating UpstreamWrite/VirtualEnables to the IRI
cpu.gicv3.EOI-check-ID=0                              # (bool  , init-time) default = '0'      : Check Interrupt ID specified for accesses to EOI registers (rather than just ending highest priority active interrupt).
cpu.gicv3.EOI-check-CPUID=0                           # (bool  , init-time) default = '0'      : Check CPU ID specified for accesses to EOI registers (rather than just ending highest priority active interrupt).
cpu.gicv3.EOI-deactivate-any-interrupt=0              # (bool  , init-time) default = '0'      : Allow an EOI to deactivate interrupts that aren't the highest priority active interrupt (EOI-ignore-out-of-order must be false otherwise this is ignored).
cpu.gicv3.EOI-ignore-out-of-order=1                   # (bool  , init-time) default = '1'      : Ignore EOI writes that cannot end the highest priority active interrupt.
cpu.gicv3.physical-ID-bits=0x10                       # (int   , init-time) default = '0x10'   : Number of physical ID bits implemented. : [0x10..0x18]
cpu.gicv3.virtual-ID-bits=0x10                        # (int   , init-time) default = '0x10'   : Number of virtual ID bits implemented. : [0x10..0x18]
cpu.gicv3.priority-bits=0x5                           # (int   , init-time) default = '0x5'    : Number of priority bits implemented. : [0x4..0x8]
cpu.gicv3.virtual-priority-bits=0x5                   # (int   , init-time) default = '0x5'    : Number of virtual priority bits implemented. : [0x5..0x8]
cpu.gicv3.A3-affinity-supported=0                     # (bool  , init-time) default = '0'      : Whether a non-zero value for affinity at level 3 is supported.
cpu.gicv3.sgi-range-selector-support=0                # (bool  , init-time) default = '0'      : Device has support for the Range Selector feature for SGI
cpu.gicv3.extended-interrupt-range-support=0          # (bool  , init-time) default = '0'      : Device has support for extended SPI/PPI ID ranges
cpu.gicv3.cpuintf-mmap-access-level=0x0               # (int   , init-time) default = '0x0'    : Allowed values are: 0-mmap access is supported for GICC,GICH,GICV registers. 1-mmap access is supported only for GICV registers. 2-mmap access is not supported. : [0x0..0x2]
cpu.gicv3.SRE-enable-action-on-mmap=0x0               # (int   , init-time) default = '0x0'    : Allowed values are: 0-SRE one allows mmap access. 1-SRE one disables mmap access. 2-SRE one makes mmap access RAZ-WI. : [0x0..0x2]
cpu.gicv3.SRE-EL3-set-once=0                          # (bool  , init-time) default = '0'      : Restrict SRE EL3 to be set only once
cpu.gicv3.SRE-EL3-enable-RAO=0                        # (bool  , init-time) default = '0'      : When ICC_SRE_EL3.SRE is RAO/WI, makes ICC_SRE_EL3.Enable RAO/WI
cpu.gicv3.SRE-EL2-enable-RAO=0                        # (bool  , init-time) default = '0'      : When ICC_SRE_EL2.SRE is RAO/WI, makes ICC_SRE_EL2.Enable RAO/WI
cpu.gicv3.PMHE-RAO-WI=0                               # (bool  , init-time) default = '0'      : ICC_CTLR_EL*.PHME is read as one, write insensitive
cpu.gicv3.PMHE-RAZ-WI=0                               # (bool  , init-time) default = '0'      : ICC_CTLR_EL*.PHME is read as zero, write insensitive
cpu.gicv3.PMHE-release-set-packet=0                   # (bool  , init-time) default = '0'      : if PHME is enabled, whether a SET packet is released by CPU Intf in Upstream Ack window.
cpu.gicv3.dir-trap-support=1                          # (bool  , init-time) default = '1'      : The cpu supports separate trapping of ICC_DIR_EL1 to EL2
cpu.gicv3.FIQEn-RAO=0                                 # (bool  , init-time) default = '0'      : GICC_CTLR.FIQEn is read as one, write insensitive
cpu.gicv3.VFIQEn-RAO=0                                # (bool  , init-time) default = '0'      : ICH_VMCR_EL2.VFIQEn is read as one, write insensitive
cpu.gicv3.interrupt-bypass-support=1                  # (bool  , init-time) default = '1'      : Interrupt bypass support, set to false for devices not supporting interrupt bypass
cpu.gicv3.local-SEIs=0                                # (bool  , init-time) default = '0'      : Generate SEI to signal internal issues
cpu.gicv3.local-VSEIs=0                               # (bool  , init-time) default = '0'      : Generate VSEI to signal internal issues
cpu.gicv3.idle-is-ff=1                                # (bool  , init-time) default = '1'      : For GICC/GICV RPR, when idle, return FF when true, minimum supported priority otherwise
cpu.gicv3.without-DS-support=0                        # (bool  , init-time) default = '0'      : GICv3 CPU interfaces do not support disabling security in the distributor (GICD_CTLR.DS=1)
cpu.gic.GICD-offset=0x1000                            # (int   , init-time) default = '0x1000' : Offset from PERIPHBASE for GICD registers. Will be ignored when GICv3 CPU interface is enabled, as distributor is then external to the cluster. : [0x0..0xFF000]
cpu.gic.GICC-offset=0x2000                            # (int   , init-time) default = '0x2000' : Offset from PERIPHBASE for GICC registers. : [0x0..0xFF000]
cpu.gic.GICH-offset=0x4000                            # (int   , init-time) default = '0x4000' : Offset from PERIPHBASE for GICH registers. : [0x0..0xFF000]
cpu.gic.GICH-other-CPU-offset=0x5000                  # (int   , init-time) default = '0x5000' : Offset from PERIPHBASE for GICH registers for accessing other CPUs in the cluster. Set to 0 to disable. : [0x0..0xFF000]
cpu.gic.GICV-offset=0x6000                            # (int   , init-time) default = '0x6000' : Offset from PERIPHBASE for GICV registers. : [0x0..0xFE000]
cpu.gic.GICV-alias=0x0                                # (int   , init-time) default = '0x0'    : Offset from PERIPHBASE for alias of GICV registers. When gicv2-only, if zero no alias will be created; if gicv2-only=0, the param is deprecated, when zero or unset an alias is created in the place mandated by the architecture (GICV-base+0xF000) : [0x0..0xFE000]
cpu.gic.PERIPH-size=0x8000                            # (int   , init-time) default = '0x8000' : Size of registers based at PERIPHBASE that are considered to be owned by the GIC.  Any accesses in the range PERIPHBASE to PERIPHBASE+gic.PERIPH-size-1 that do not match GIC registers will be treated as RAZ/WI. : [0x0..0x400000]
cpu.user_defined_rom_table_debug_memory_map=""        # (string, init-time) default = ''       : User defined ROM Table debug memory map for ED,CTI,PMU and TRACE. JSON schema for the parameter value is: {"format":"all_addrs_are_absolute_wrt_debugbus","cores": [{"ed":0x0,"cti":0x0,"pmu":0x0,"etm":0x0},{"ed":0x0,"cti":0x0,"pmu":0x0,"etm":0x0},{"ed":0x0,"cti":0x0,"pmu":0x0,"etm":0x0},{"ed":0x0,"cti":0x0,"pmu":0x0,"etm":0x0}]}
cpu.user_defined_rom_table_debug_power_config=""      # (string, init-time) default = ''       : User defined ROM Table debug power domains for ED,CTI,PMU and TRACE, and DBGPCR configuration. The "version" field and "cores" array are mandatory. The "dbgpcr" array, if provided, must contain unique integers in the range [0, 32) describing which debug power domains have power control implemented. The "rom" and "dbgpcr" fields in objects in the "cores" array are only allowed when 'debug_rom_is_flat' is false. All power domain ID fields ("rom", "ed/pmu", "cti", "etm") must be in the range [0, 32). The "ed/pmu" field is mandatory. Example JSON for a hierarchical debug ROM layout: '{"version": 0, "dbgpcr": [0, 1], "cores":[{"dbgpcr": [1, 31], "rom": 0 "ed/pmu": 0, "cti": 31, "etm": 1}, {"ed/pmu": 0}]}'
cpu.l3cache-has_mpam=0                                # (bool  , init-time) default = '0'      : L3 Cache has MPAM support
cpu.l3cache-mpamf_base=0x0                            # (int   , init-time) default = '0x0'    : L3 Cache memory mapped MPAM registers base address : [0x0..0xFFFFFFFFFFFF]
cpu.l3cache-mpamf.max_partid_s=0xFFFF                 # (int   , init-time) default = '0xFFFF' : L3 Cache Maximum value of secure PARTID supported. : [0x0..0xFFFF]
cpu.l3cache-mpamf.max_pmg_s=0xFF                      # (int   , init-time) default = '0xFF'   : L3 Cache Maximum value of secure PMG supported. : [0x0..0xFF]
cpu.l3cache-mpamf.max_partid_ns=0xFFFF                # (int   , init-time) default = '0xFFFF' : L3 Cache Maximum value of non-secure PARTID supported. : [0x0..0xFFFF]
cpu.l3cache-mpamf.max_pmg_ns=0xFF                     # (int   , init-time) default = '0xFF'   : L3 Cache Maximum value of non-secure PMG supported. : [0x0..0xFF]
cpu.cpu0.crypto_sha512=0x0                            # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SHA-512 instructions (requires CryptoPlugin to be loaded).

Possible values of this parameter are:
  - 0, feature is not enabled.
  - 1, feature is implemented if ARMv8.4 is enabled.
  - 2, feature is implemented. : [0x0..0x2]
cpu.cpu0.crypto_sha3=0x0                              # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SHA-3 instructions (requires CryptoPlugin to be loaded).

Possible values of this parameter are:
  - 0, feature is not enabled.
  - 1, feature is implemented if ARMv8.4 is enabled.
  - 2, feature is implemented. : [0x0..0x2]
cpu.cpu0.crypto_sm3=0x0                               # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SM-3 instructions (requires CryptoPlugin to be loaded).

Possible values of this parameter are:
  - 0, feature is not enabled.
  - 1, feature is implemented if ARMv8.4 is enabled.
  - 2, feature is implemented. : [0x0..0x2]
cpu.cpu0.crypto_sm4=0x0                               # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SM-4 instructions (requires CryptoPlugin to be loaded).

Possible values of this parameter are:
  - 0, feature is not enabled.
  - 1, feature is implemented if ARMv8.4 is enabled.
  - 2, feature is implemented. : [0x0..0x2]
cpu.cpu0.operation_bandwidth=0x1                      # (int   , init-time) default = '0x1'    : Operation width for ARMv8.4 PMU extension : [0x0..0xFF]
cpu.cpu0.vfp-present=1                                # (bool  , init-time) default = '1'      : Set whether the model has VFP support
cpu.cpu0.ase-present=1                                # (bool  , init-time) default = '1'      : Set whether the model has been built with NEON support
cpu.cpu0.etm-present=1                                # (bool  , init-time) default = '1'      : Set whether the model has ETM support
cpu.cpu0.SMPnAMP=1                                    # (bool  , init-time) default = '1'      : Enable broadcast messages necessary for correct SMP operation at reset.
cpu.cpu0.vfp-enable_at_reset=0                        # (bool  , init-time) default = '0'      : Enable VFP in CPACR, CPPWR, NSACR at reset. Warning: Arm recommends going through the implementation's suggested VFP power-up sequence!
cpu.cpu0.semihosting-enable=0                         # (bool  , init-time) default = '0'      : 
cpu.cpu0.semihosting-ARM_SVC=0x123456                 # (int   , init-time) default = '0x123456' : A32 SVC number for semihosting calls. : [0x0..0xFFFFFF]
cpu.cpu0.semihosting-Thumb_SVC=0xAB                   # (int   , init-time) default = '0xAB'   : T32 SVC number for semihosting calls. : [0x0..0xFF]
cpu.cpu0.semihosting-A64_HLT=0xF000                   # (int   , init-time) default = '0xF000' : A64 HLT number for semihosting calls. : [0x0..0xFFFF]
cpu.cpu0.semihosting-A32_HLT=0xF000                   # (int   , init-time) default = '0xF000' : A32 HLT number for semihosting calls. : [0x0..0xFFFF]
cpu.cpu0.semihosting-T32_HLT=0x3C                     # (int   , init-time) default = '0x3C'   : T32 HLT number for semihosting calls. : [0x0..0x3F]
cpu.cpu0.semihosting-cmd_line=""                      # (string, init-time) default = ''       : Command line available to semihosting calls.
cpu.cpu0.semihosting-heap_base=0x0                    # (int   , init-time) default = '0x0'    : Virtual address of heap base.
cpu.cpu0.semihosting-heap_limit=0xF000000             # (int   , init-time) default = '0xF000000' : Virtual address of top of heap.
cpu.cpu0.semihosting-stack_base=0x10000000            # (int   , init-time) default = '0x10000000' : Virtual address of base of descending stack.
cpu.cpu0.semihosting-stack_limit=0xF000000            # (int   , init-time) default = '0xF000000' : Virtual address of stack limit.
cpu.cpu0.semihosting-cwd=""                           # (string, init-time) default = ''       : Base directory for semihosting file access.
cpu.cpu0.semihosting-use_stderr=0                     # (bool  , init-time) default = '0'      : Send stderr from the simulated process to host stderr
cpu.cpu0.semihosting-stdin_istty=1                    # (bool  , init-time) default = '1'      : Result for semihost istty call when argument is stdin
cpu.cpu0.semihosting-stdout_istty=1                   # (bool  , init-time) default = '1'      : Result for semihost istty call when argument is stdout
cpu.cpu0.semihosting-stderr_istty=1                   # (bool  , init-time) default = '1'      : Result for semihost istty call when argument is stderr
cpu.cpu0.semihosting-prefix=0                         # (bool  , init-time) default = '0'      : Prefix semihosting output with target instance name
cpu.cpu0.enable_trace_special_hlt_imm16=0             # (bool  , init-time) default = '0'      : Enable usage of parameter trace_special_hlt_imm16
cpu.cpu0.trace_special_hlt_imm16=0xF000               # (int   , init-time) default = '0xF000' : For this HLT number, IF enable_trace_special_hlt_imm16=true, skip performing usual HLT execution but call MTI trace if registered : [0x0..0xFFFF]
cpu.cpu0.RVBAR=0x0                                    # (int   , init-time) default = '0x0'    : Value of RVBAR_ELx register. : [0x0..0xFFFFFFFFFFFC]
cpu.cpu0.vfp-traps=1                                  # (bool  , init-time) default = '1'      : Implement support for trapping floating-point exceptions
cpu.cpu0.vfp-traps-show-all=0                         # (bool  , init-time) default = '0'      : Report all trapped floating-point exceptions in the syndrome when a combination occurs.
cpu.cpu0.min_sync_level=0x0                           # (int   , run-time ) default = '0x0'    : Force minimum syncLevel (0=off=default,1=syncState,2=postInsnIO,3=postInsnAll) : [0x0..0x3]
cpu.cpu0.cti-number_of_triggers=0x8                   # (int   , init-time) default = '0x8'    : Number of cti event triggers : [0x0..0x8]
cpu.cpu0.cti-intack_mask=0x1                          # (int   , init-time) default = '0x1'    : Set bits represent that the corresponding trigger requires software acknowledge via CTIINTACK : [0x0..0xFF]
cpu.cpu0.cti-number_of_claim_bits=0x0                 # (int   , init-time) default = '0x0'    : Number of implemented bits in CTICLAIMSET : [0x0..0x1F]
cpu.cpu0.crypto_aes=0x2                               # (int   , init-time) default = '0x2'    : AES instructions supported (requires CryptoPlugin to be loaded). 0, not implemented. 1, AES instructions implemented. 2, AES and PMULL instructions implemented. : [0x0..0x2]
cpu.cpu0.crypto_sha1=0x1                              # (int   , init-time) default = '0x1'    : SHA-1 instructions supported (requires CryptoPlugin to be loaded). 0, not implemented. 1, SHA1 instructions implemented. : [0x0..0x1]
cpu.cpu0.crypto_sha256=0x1                            # (int   , init-time) default = '0x1'    : SHA-256 instructions supported (requires CryptoPlugin to be loaded). 0, not implemented. 1, SHA256 instructions implemented. : [0x0..0x1]
cpu.cpu0.enable_crc32=0x0                             # (int   , init-time) default = '0x0'    : CRC32 instructions supported. 0, not implemented. 1, CRC32 instructions implemented. : [0x0..0x1]
cpu.cpu0.CRYPTODISABLE=0                              # (bool  , init-time) default = '0'      : Disable cryptographic features.
cpu.cpu0.max_code_cache_mb=0x100                      # (int   , init-time) default = '0x100'  : Maximum size of the simulation code cache (MiB). For platforms with more than 2 cores this limit will be scaled down. (e.g 1/8 for 16 or more cores) : [0x1..0x4000]
cpu.cpu0.force-fpsid=0                                # (bool  , init-time) default = '0'      : Override the FPSID value
cpu.cpu0.force-fpsid-value=0x0                        # (int   , init-time) default = '0x0'    : Value to override the FPSID value to : [0x0..0xFFFFFFFF]
cpu.cpu0.number-of-breakpoints=0x10                   # (int   , init-time) default = '0x10'   : Number of breakpoints. : [0x2..0x10]
cpu.cpu0.number-of-watchpoints=0x10                   # (int   , init-time) default = '0x10'   : Number of watchpoints. : [0x2..0x10]
cpu.cpu0.number-of-context-breakpoints=0x10           # (int   , init-time) default = '0x10'   : Number of breakpoints that are context aware. : [0x0..0x10]
cpu.cpu0.DCZID-log2-block-size=0x8                    # (int   , init-time) default = '0x8'    : Log2 of the block size cleared by DC ZVA instruction (as read from DCZID_EL0). : [0x0..0x9]
cpu.cpu0.DCZVA_single_write=0                         # (bool  , init-time) default = '0'      : Execute the DCZVA as a single write
cpu.cpu0.unpredictable_WPMASKANDBAS=0x1               # (int   , init-time) default = '0x1'    : Constrained unpredictable handling of watchpoints when mask and BAS fields specified. 0, IGNOREMASK. 1, IGNOREBAS (default). 2, REPEATBAS8. 3, REPEATBAS. : [0x0..0x3]
cpu.cpu0.has_hcptr_tase=1                             # (bool  , init-time) default = '1'      : If false, HCPTR.TASE is RES0
cpu.cpu0.MPIDR-override=0x0                           # (int   , init-time) default = '0x0'    : Override of MPIDR value.  If nonzero will override the MT, cluster and CPU ID bits in MPIDR. : [0x0..0xFFFFFFFFFF]
cpu.cpu0.clock_divider=0x1                            # (int   , run-time ) default = '0x1'    : Clock divider ratio for asymmetric MP clocking. : [0x1..0xFFFFFFFF]
cpu.cpu0.clock_multiplier=0x1                         # (int   , run-time ) default = '0x1'    : Clock divider ratio for asymmetric MP clocking. : [0x1..0xFFFFFFFF]
cpu.cpu1.crypto_sha512=0x0                            # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SHA-512 instructions (requires CryptoPlugin to be loaded).

Possible values of this parameter are:
  - 0, feature is not enabled.
  - 1, feature is implemented if ARMv8.4 is enabled.
  - 2, feature is implemented. : [0x0..0x2]
cpu.cpu1.crypto_sha3=0x0                              # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SHA-3 instructions (requires CryptoPlugin to be loaded).

Possible values of this parameter are:
  - 0, feature is not enabled.
  - 1, feature is implemented if ARMv8.4 is enabled.
  - 2, feature is implemented. : [0x0..0x2]
cpu.cpu1.crypto_sm3=0x0                               # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SM-3 instructions (requires CryptoPlugin to be loaded).

Possible values of this parameter are:
  - 0, feature is not enabled.
  - 1, feature is implemented if ARMv8.4 is enabled.
  - 2, feature is implemented. : [0x0..0x2]
cpu.cpu1.crypto_sm4=0x0                               # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SM-4 instructions (requires CryptoPlugin to be loaded).

Possible values of this parameter are:
  - 0, feature is not enabled.
  - 1, feature is implemented if ARMv8.4 is enabled.
  - 2, feature is implemented. : [0x0..0x2]
cpu.cpu1.operation_bandwidth=0x1                      # (int   , init-time) default = '0x1'    : Operation width for ARMv8.4 PMU extension : [0x0..0xFF]
cpu.cpu1.vfp-present=1                                # (bool  , init-time) default = '1'      : Set whether the model has VFP support
cpu.cpu1.ase-present=1                                # (bool  , init-time) default = '1'      : Set whether the model has been built with NEON support
cpu.cpu1.etm-present=1                                # (bool  , init-time) default = '1'      : Set whether the model has ETM support
cpu.cpu1.SMPnAMP=1                                    # (bool  , init-time) default = '1'      : Enable broadcast messages necessary for correct SMP operation at reset.
cpu.cpu1.vfp-enable_at_reset=0                        # (bool  , init-time) default = '0'      : Enable VFP in CPACR, CPPWR, NSACR at reset. Warning: Arm recommends going through the implementation's suggested VFP power-up sequence!
cpu.cpu1.semihosting-enable=0                         # (bool  , init-time) default = '0'      : 
cpu.cpu1.semihosting-ARM_SVC=0x123456                 # (int   , init-time) default = '0x123456' : A32 SVC number for semihosting calls. : [0x0..0xFFFFFF]
cpu.cpu1.semihosting-Thumb_SVC=0xAB                   # (int   , init-time) default = '0xAB'   : T32 SVC number for semihosting calls. : [0x0..0xFF]
cpu.cpu1.semihosting-A64_HLT=0xF000                   # (int   , init-time) default = '0xF000' : A64 HLT number for semihosting calls. : [0x0..0xFFFF]
cpu.cpu1.semihosting-A32_HLT=0xF000                   # (int   , init-time) default = '0xF000' : A32 HLT number for semihosting calls. : [0x0..0xFFFF]
cpu.cpu1.semihosting-T32_HLT=0x3C                     # (int   , init-time) default = '0x3C'   : T32 HLT number for semihosting calls. : [0x0..0x3F]
cpu.cpu1.semihosting-cmd_line=""                      # (string, init-time) default = ''       : Command line available to semihosting calls.
cpu.cpu1.semihosting-heap_base=0x0                    # (int   , init-time) default = '0x0'    : Virtual address of heap base.
cpu.cpu1.semihosting-heap_limit=0xF000000             # (int   , init-time) default = '0xF000000' : Virtual address of top of heap.
cpu.cpu1.semihosting-stack_base=0x10000000            # (int   , init-time) default = '0x10000000' : Virtual address of base of descending stack.
cpu.cpu1.semihosting-stack_limit=0xF000000            # (int   , init-time) default = '0xF000000' : Virtual address of stack limit.
cpu.cpu1.semihosting-cwd=""                           # (string, init-time) default = ''       : Base directory for semihosting file access.
cpu.cpu1.semihosting-use_stderr=0                     # (bool  , init-time) default = '0'      : Send stderr from the simulated process to host stderr
cpu.cpu1.semihosting-stdin_istty=1                    # (bool  , init-time) default = '1'      : Result for semihost istty call when argument is stdin
cpu.cpu1.semihosting-stdout_istty=1                   # (bool  , init-time) default = '1'      : Result for semihost istty call when argument is stdout
cpu.cpu1.semihosting-stderr_istty=1                   # (bool  , init-time) default = '1'      : Result for semihost istty call when argument is stderr
cpu.cpu1.semihosting-prefix=0                         # (bool  , init-time) default = '0'      : Prefix semihosting output with target instance name
cpu.cpu1.enable_trace_special_hlt_imm16=0             # (bool  , init-time) default = '0'      : Enable usage of parameter trace_special_hlt_imm16
cpu.cpu1.trace_special_hlt_imm16=0xF000               # (int   , init-time) default = '0xF000' : For this HLT number, IF enable_trace_special_hlt_imm16=true, skip performing usual HLT execution but call MTI trace if registered : [0x0..0xFFFF]
cpu.cpu1.RVBAR=0x0                                    # (int   , init-time) default = '0x0'    : Value of RVBAR_ELx register. : [0x0..0xFFFFFFFFFFFC]
cpu.cpu1.vfp-traps=1                                  # (bool  , init-time) default = '1'      : Implement support for trapping floating-point exceptions
cpu.cpu1.vfp-traps-show-all=0                         # (bool  , init-time) default = '0'      : Report all trapped floating-point exceptions in the syndrome when a combination occurs.
cpu.cpu1.min_sync_level=0x0                           # (int   , run-time ) default = '0x0'    : Force minimum syncLevel (0=off=default,1=syncState,2=postInsnIO,3=postInsnAll) : [0x0..0x3]
cpu.cpu1.cti-number_of_triggers=0x8                   # (int   , init-time) default = '0x8'    : Number of cti event triggers : [0x0..0x8]
cpu.cpu1.cti-intack_mask=0x1                          # (int   , init-time) default = '0x1'    : Set bits represent that the corresponding trigger requires software acknowledge via CTIINTACK : [0x0..0xFF]
cpu.cpu1.cti-number_of_claim_bits=0x0                 # (int   , init-time) default = '0x0'    : Number of implemented bits in CTICLAIMSET : [0x0..0x1F]
cpu.cpu1.crypto_aes=0x2                               # (int   , init-time) default = '0x2'    : AES instructions supported (requires CryptoPlugin to be loaded). 0, not implemented. 1, AES instructions implemented. 2, AES and PMULL instructions implemented. : [0x0..0x2]
cpu.cpu1.crypto_sha1=0x1                              # (int   , init-time) default = '0x1'    : SHA-1 instructions supported (requires CryptoPlugin to be loaded). 0, not implemented. 1, SHA1 instructions implemented. : [0x0..0x1]
cpu.cpu1.crypto_sha256=0x1                            # (int   , init-time) default = '0x1'    : SHA-256 instructions supported (requires CryptoPlugin to be loaded). 0, not implemented. 1, SHA256 instructions implemented. : [0x0..0x1]
cpu.cpu1.enable_crc32=0x0                             # (int   , init-time) default = '0x0'    : CRC32 instructions supported. 0, not implemented. 1, CRC32 instructions implemented. : [0x0..0x1]
cpu.cpu1.CRYPTODISABLE=0                              # (bool  , init-time) default = '0'      : Disable cryptographic features.
cpu.cpu1.max_code_cache_mb=0x100                      # (int   , init-time) default = '0x100'  : Maximum size of the simulation code cache (MiB). For platforms with more than 2 cores this limit will be scaled down. (e.g 1/8 for 16 or more cores) : [0x1..0x4000]
cpu.cpu1.force-fpsid=0                                # (bool  , init-time) default = '0'      : Override the FPSID value
cpu.cpu1.force-fpsid-value=0x0                        # (int   , init-time) default = '0x0'    : Value to override the FPSID value to : [0x0..0xFFFFFFFF]
cpu.cpu1.number-of-breakpoints=0x10                   # (int   , init-time) default = '0x10'   : Number of breakpoints. : [0x2..0x10]
cpu.cpu1.number-of-watchpoints=0x10                   # (int   , init-time) default = '0x10'   : Number of watchpoints. : [0x2..0x10]
cpu.cpu1.number-of-context-breakpoints=0x10           # (int   , init-time) default = '0x10'   : Number of breakpoints that are context aware. : [0x0..0x10]
cpu.cpu1.DCZID-log2-block-size=0x8                    # (int   , init-time) default = '0x8'    : Log2 of the block size cleared by DC ZVA instruction (as read from DCZID_EL0). : [0x0..0x9]
cpu.cpu1.DCZVA_single_write=0                         # (bool  , init-time) default = '0'      : Execute the DCZVA as a single write
cpu.cpu1.unpredictable_WPMASKANDBAS=0x1               # (int   , init-time) default = '0x1'    : Constrained unpredictable handling of watchpoints when mask and BAS fields specified. 0, IGNOREMASK. 1, IGNOREBAS (default). 2, REPEATBAS8. 3, REPEATBAS. : [0x0..0x3]
cpu.cpu1.has_hcptr_tase=1                             # (bool  , init-time) default = '1'      : If false, HCPTR.TASE is RES0
cpu.cpu1.MPIDR-override=0x0                           # (int   , init-time) default = '0x0'    : Override of MPIDR value.  If nonzero will override the MT, cluster and CPU ID bits in MPIDR. : [0x0..0xFFFFFFFFFF]
cpu.cpu1.clock_divider=0x1                            # (int   , run-time ) default = '0x1'    : Clock divider ratio for asymmetric MP clocking. : [0x1..0xFFFFFFFF]
cpu.cpu1.clock_multiplier=0x1                         # (int   , run-time ) default = '0x1'    : Clock divider ratio for asymmetric MP clocking. : [0x1..0xFFFFFFFF]
cpu.cpu2.crypto_sha512=0x0                            # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SHA-512 instructions (requires CryptoPlugin to be loaded).

Possible values of this parameter are:
  - 0, feature is not enabled.
  - 1, feature is implemented if ARMv8.4 is enabled.
  - 2, feature is implemented. : [0x0..0x2]
cpu.cpu2.crypto_sha3=0x0                              # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SHA-3 instructions (requires CryptoPlugin to be loaded).

Possible values of this parameter are:
  - 0, feature is not enabled.
  - 1, feature is implemented if ARMv8.4 is enabled.
  - 2, feature is implemented. : [0x0..0x2]
cpu.cpu2.crypto_sm3=0x0                               # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SM-3 instructions (requires CryptoPlugin to be loaded).

Possible values of this parameter are:
  - 0, feature is not enabled.
  - 1, feature is implemented if ARMv8.4 is enabled.
  - 2, feature is implemented. : [0x0..0x2]
cpu.cpu2.crypto_sm4=0x0                               # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SM-4 instructions (requires CryptoPlugin to be loaded).

Possible values of this parameter are:
  - 0, feature is not enabled.
  - 1, feature is implemented if ARMv8.4 is enabled.
  - 2, feature is implemented. : [0x0..0x2]
cpu.cpu2.operation_bandwidth=0x1                      # (int   , init-time) default = '0x1'    : Operation width for ARMv8.4 PMU extension : [0x0..0xFF]
cpu.cpu2.vfp-present=1                                # (bool  , init-time) default = '1'      : Set whether the model has VFP support
cpu.cpu2.ase-present=1                                # (bool  , init-time) default = '1'      : Set whether the model has been built with NEON support
cpu.cpu2.etm-present=1                                # (bool  , init-time) default = '1'      : Set whether the model has ETM support
cpu.cpu2.SMPnAMP=1                                    # (bool  , init-time) default = '1'      : Enable broadcast messages necessary for correct SMP operation at reset.
cpu.cpu2.vfp-enable_at_reset=0                        # (bool  , init-time) default = '0'      : Enable VFP in CPACR, CPPWR, NSACR at reset. Warning: Arm recommends going through the implementation's suggested VFP power-up sequence!
cpu.cpu2.semihosting-enable=0                         # (bool  , init-time) default = '0'      : 
cpu.cpu2.semihosting-ARM_SVC=0x123456                 # (int   , init-time) default = '0x123456' : A32 SVC number for semihosting calls. : [0x0..0xFFFFFF]
cpu.cpu2.semihosting-Thumb_SVC=0xAB                   # (int   , init-time) default = '0xAB'   : T32 SVC number for semihosting calls. : [0x0..0xFF]
cpu.cpu2.semihosting-A64_HLT=0xF000                   # (int   , init-time) default = '0xF000' : A64 HLT number for semihosting calls. : [0x0..0xFFFF]
cpu.cpu2.semihosting-A32_HLT=0xF000                   # (int   , init-time) default = '0xF000' : A32 HLT number for semihosting calls. : [0x0..0xFFFF]
cpu.cpu2.semihosting-T32_HLT=0x3C                     # (int   , init-time) default = '0x3C'   : T32 HLT number for semihosting calls. : [0x0..0x3F]
cpu.cpu2.semihosting-cmd_line=""                      # (string, init-time) default = ''       : Command line available to semihosting calls.
cpu.cpu2.semihosting-heap_base=0x0                    # (int   , init-time) default = '0x0'    : Virtual address of heap base.
cpu.cpu2.semihosting-heap_limit=0xF000000             # (int   , init-time) default = '0xF000000' : Virtual address of top of heap.
cpu.cpu2.semihosting-stack_base=0x10000000            # (int   , init-time) default = '0x10000000' : Virtual address of base of descending stack.
cpu.cpu2.semihosting-stack_limit=0xF000000            # (int   , init-time) default = '0xF000000' : Virtual address of stack limit.
cpu.cpu2.semihosting-cwd=""                           # (string, init-time) default = ''       : Base directory for semihosting file access.
cpu.cpu2.semihosting-use_stderr=0                     # (bool  , init-time) default = '0'      : Send stderr from the simulated process to host stderr
cpu.cpu2.semihosting-stdin_istty=1                    # (bool  , init-time) default = '1'      : Result for semihost istty call when argument is stdin
cpu.cpu2.semihosting-stdout_istty=1                   # (bool  , init-time) default = '1'      : Result for semihost istty call when argument is stdout
cpu.cpu2.semihosting-stderr_istty=1                   # (bool  , init-time) default = '1'      : Result for semihost istty call when argument is stderr
cpu.cpu2.semihosting-prefix=0                         # (bool  , init-time) default = '0'      : Prefix semihosting output with target instance name
cpu.cpu2.enable_trace_special_hlt_imm16=0             # (bool  , init-time) default = '0'      : Enable usage of parameter trace_special_hlt_imm16
cpu.cpu2.trace_special_hlt_imm16=0xF000               # (int   , init-time) default = '0xF000' : For this HLT number, IF enable_trace_special_hlt_imm16=true, skip performing usual HLT execution but call MTI trace if registered : [0x0..0xFFFF]
cpu.cpu2.RVBAR=0x0                                    # (int   , init-time) default = '0x0'    : Value of RVBAR_ELx register. : [0x0..0xFFFFFFFFFFFC]
cpu.cpu2.vfp-traps=1                                  # (bool  , init-time) default = '1'      : Implement support for trapping floating-point exceptions
cpu.cpu2.vfp-traps-show-all=0                         # (bool  , init-time) default = '0'      : Report all trapped floating-point exceptions in the syndrome when a combination occurs.
cpu.cpu2.min_sync_level=0x0                           # (int   , run-time ) default = '0x0'    : Force minimum syncLevel (0=off=default,1=syncState,2=postInsnIO,3=postInsnAll) : [0x0..0x3]
cpu.cpu2.cti-number_of_triggers=0x8                   # (int   , init-time) default = '0x8'    : Number of cti event triggers : [0x0..0x8]
cpu.cpu2.cti-intack_mask=0x1                          # (int   , init-time) default = '0x1'    : Set bits represent that the corresponding trigger requires software acknowledge via CTIINTACK : [0x0..0xFF]
cpu.cpu2.cti-number_of_claim_bits=0x0                 # (int   , init-time) default = '0x0'    : Number of implemented bits in CTICLAIMSET : [0x0..0x1F]
cpu.cpu2.crypto_aes=0x2                               # (int   , init-time) default = '0x2'    : AES instructions supported (requires CryptoPlugin to be loaded). 0, not implemented. 1, AES instructions implemented. 2, AES and PMULL instructions implemented. : [0x0..0x2]
cpu.cpu2.crypto_sha1=0x1                              # (int   , init-time) default = '0x1'    : SHA-1 instructions supported (requires CryptoPlugin to be loaded). 0, not implemented. 1, SHA1 instructions implemented. : [0x0..0x1]
cpu.cpu2.crypto_sha256=0x1                            # (int   , init-time) default = '0x1'    : SHA-256 instructions supported (requires CryptoPlugin to be loaded). 0, not implemented. 1, SHA256 instructions implemented. : [0x0..0x1]
cpu.cpu2.enable_crc32=0x0                             # (int   , init-time) default = '0x0'    : CRC32 instructions supported. 0, not implemented. 1, CRC32 instructions implemented. : [0x0..0x1]
cpu.cpu2.CRYPTODISABLE=0                              # (bool  , init-time) default = '0'      : Disable cryptographic features.
cpu.cpu2.max_code_cache_mb=0x100                      # (int   , init-time) default = '0x100'  : Maximum size of the simulation code cache (MiB). For platforms with more than 2 cores this limit will be scaled down. (e.g 1/8 for 16 or more cores) : [0x1..0x4000]
cpu.cpu2.force-fpsid=0                                # (bool  , init-time) default = '0'      : Override the FPSID value
cpu.cpu2.force-fpsid-value=0x0                        # (int   , init-time) default = '0x0'    : Value to override the FPSID value to : [0x0..0xFFFFFFFF]
cpu.cpu2.number-of-breakpoints=0x10                   # (int   , init-time) default = '0x10'   : Number of breakpoints. : [0x2..0x10]
cpu.cpu2.number-of-watchpoints=0x10                   # (int   , init-time) default = '0x10'   : Number of watchpoints. : [0x2..0x10]
cpu.cpu2.number-of-context-breakpoints=0x10           # (int   , init-time) default = '0x10'   : Number of breakpoints that are context aware. : [0x0..0x10]
cpu.cpu2.DCZID-log2-block-size=0x8                    # (int   , init-time) default = '0x8'    : Log2 of the block size cleared by DC ZVA instruction (as read from DCZID_EL0). : [0x0..0x9]
cpu.cpu2.DCZVA_single_write=0                         # (bool  , init-time) default = '0'      : Execute the DCZVA as a single write
cpu.cpu2.unpredictable_WPMASKANDBAS=0x1               # (int   , init-time) default = '0x1'    : Constrained unpredictable handling of watchpoints when mask and BAS fields specified. 0, IGNOREMASK. 1, IGNOREBAS (default). 2, REPEATBAS8. 3, REPEATBAS. : [0x0..0x3]
cpu.cpu2.has_hcptr_tase=1                             # (bool  , init-time) default = '1'      : If false, HCPTR.TASE is RES0
cpu.cpu2.MPIDR-override=0x0                           # (int   , init-time) default = '0x0'    : Override of MPIDR value.  If nonzero will override the MT, cluster and CPU ID bits in MPIDR. : [0x0..0xFFFFFFFFFF]
cpu.cpu2.clock_divider=0x1                            # (int   , run-time ) default = '0x1'    : Clock divider ratio for asymmetric MP clocking. : [0x1..0xFFFFFFFF]
cpu.cpu2.clock_multiplier=0x1                         # (int   , run-time ) default = '0x1'    : Clock divider ratio for asymmetric MP clocking. : [0x1..0xFFFFFFFF]
cpu.cpu3.crypto_sha512=0x0                            # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SHA-512 instructions (requires CryptoPlugin to be loaded).

Possible values of this parameter are:
  - 0, feature is not enabled.
  - 1, feature is implemented if ARMv8.4 is enabled.
  - 2, feature is implemented. : [0x0..0x2]
cpu.cpu3.crypto_sha3=0x0                              # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SHA-3 instructions (requires CryptoPlugin to be loaded).

Possible values of this parameter are:
  - 0, feature is not enabled.
  - 1, feature is implemented if ARMv8.4 is enabled.
  - 2, feature is implemented. : [0x0..0x2]
cpu.cpu3.crypto_sm3=0x0                               # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SM-3 instructions (requires CryptoPlugin to be loaded).

Possible values of this parameter are:
  - 0, feature is not enabled.
  - 1, feature is implemented if ARMv8.4 is enabled.
  - 2, feature is implemented. : [0x0..0x2]
cpu.cpu3.crypto_sm4=0x0                               # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SM-4 instructions (requires CryptoPlugin to be loaded).

Possible values of this parameter are:
  - 0, feature is not enabled.
  - 1, feature is implemented if ARMv8.4 is enabled.
  - 2, feature is implemented. : [0x0..0x2]
cpu.cpu3.operation_bandwidth=0x1                      # (int   , init-time) default = '0x1'    : Operation width for ARMv8.4 PMU extension : [0x0..0xFF]
cpu.cpu3.vfp-present=1                                # (bool  , init-time) default = '1'      : Set whether the model has VFP support
cpu.cpu3.ase-present=1                                # (bool  , init-time) default = '1'      : Set whether the model has been built with NEON support
cpu.cpu3.etm-present=1                                # (bool  , init-time) default = '1'      : Set whether the model has ETM support
cpu.cpu3.SMPnAMP=1                                    # (bool  , init-time) default = '1'      : Enable broadcast messages necessary for correct SMP operation at reset.
cpu.cpu3.vfp-enable_at_reset=0                        # (bool  , init-time) default = '0'      : Enable VFP in CPACR, CPPWR, NSACR at reset. Warning: Arm recommends going through the implementation's suggested VFP power-up sequence!
cpu.cpu3.semihosting-enable=0                         # (bool  , init-time) default = '0'      : 
cpu.cpu3.semihosting-ARM_SVC=0x123456                 # (int   , init-time) default = '0x123456' : A32 SVC number for semihosting calls. : [0x0..0xFFFFFF]
cpu.cpu3.semihosting-Thumb_SVC=0xAB                   # (int   , init-time) default = '0xAB'   : T32 SVC number for semihosting calls. : [0x0..0xFF]
cpu.cpu3.semihosting-A64_HLT=0xF000                   # (int   , init-time) default = '0xF000' : A64 HLT number for semihosting calls. : [0x0..0xFFFF]
cpu.cpu3.semihosting-A32_HLT=0xF000                   # (int   , init-time) default = '0xF000' : A32 HLT number for semihosting calls. : [0x0..0xFFFF]
cpu.cpu3.semihosting-T32_HLT=0x3C                     # (int   , init-time) default = '0x3C'   : T32 HLT number for semihosting calls. : [0x0..0x3F]
cpu.cpu3.semihosting-cmd_line=""                      # (string, init-time) default = ''       : Command line available to semihosting calls.
cpu.cpu3.semihosting-heap_base=0x0                    # (int   , init-time) default = '0x0'    : Virtual address of heap base.
cpu.cpu3.semihosting-heap_limit=0xF000000             # (int   , init-time) default = '0xF000000' : Virtual address of top of heap.
cpu.cpu3.semihosting-stack_base=0x10000000            # (int   , init-time) default = '0x10000000' : Virtual address of base of descending stack.
cpu.cpu3.semihosting-stack_limit=0xF000000            # (int   , init-time) default = '0xF000000' : Virtual address of stack limit.
cpu.cpu3.semihosting-cwd=""                           # (string, init-time) default = ''       : Base directory for semihosting file access.
cpu.cpu3.semihosting-use_stderr=0                     # (bool  , init-time) default = '0'      : Send stderr from the simulated process to host stderr
cpu.cpu3.semihosting-stdin_istty=1                    # (bool  , init-time) default = '1'      : Result for semihost istty call when argument is stdin
cpu.cpu3.semihosting-stdout_istty=1                   # (bool  , init-time) default = '1'      : Result for semihost istty call when argument is stdout
cpu.cpu3.semihosting-stderr_istty=1                   # (bool  , init-time) default = '1'      : Result for semihost istty call when argument is stderr
cpu.cpu3.semihosting-prefix=0                         # (bool  , init-time) default = '0'      : Prefix semihosting output with target instance name
cpu.cpu3.enable_trace_special_hlt_imm16=0             # (bool  , init-time) default = '0'      : Enable usage of parameter trace_special_hlt_imm16
cpu.cpu3.trace_special_hlt_imm16=0xF000               # (int   , init-time) default = '0xF000' : For this HLT number, IF enable_trace_special_hlt_imm16=true, skip performing usual HLT execution but call MTI trace if registered : [0x0..0xFFFF]
cpu.cpu3.RVBAR=0x0                                    # (int   , init-time) default = '0x0'    : Value of RVBAR_ELx register. : [0x0..0xFFFFFFFFFFFC]
cpu.cpu3.vfp-traps=1                                  # (bool  , init-time) default = '1'      : Implement support for trapping floating-point exceptions
cpu.cpu3.vfp-traps-show-all=0                         # (bool  , init-time) default = '0'      : Report all trapped floating-point exceptions in the syndrome when a combination occurs.
cpu.cpu3.min_sync_level=0x0                           # (int   , run-time ) default = '0x0'    : Force minimum syncLevel (0=off=default,1=syncState,2=postInsnIO,3=postInsnAll) : [0x0..0x3]
cpu.cpu3.cti-number_of_triggers=0x8                   # (int   , init-time) default = '0x8'    : Number of cti event triggers : [0x0..0x8]
cpu.cpu3.cti-intack_mask=0x1                          # (int   , init-time) default = '0x1'    : Set bits represent that the corresponding trigger requires software acknowledge via CTIINTACK : [0x0..0xFF]
cpu.cpu3.cti-number_of_claim_bits=0x0                 # (int   , init-time) default = '0x0'    : Number of implemented bits in CTICLAIMSET : [0x0..0x1F]
cpu.cpu3.crypto_aes=0x2                               # (int   , init-time) default = '0x2'    : AES instructions supported (requires CryptoPlugin to be loaded). 0, not implemented. 1, AES instructions implemented. 2, AES and PMULL instructions implemented. : [0x0..0x2]
cpu.cpu3.crypto_sha1=0x1                              # (int   , init-time) default = '0x1'    : SHA-1 instructions supported (requires CryptoPlugin to be loaded). 0, not implemented. 1, SHA1 instructions implemented. : [0x0..0x1]
cpu.cpu3.crypto_sha256=0x1                            # (int   , init-time) default = '0x1'    : SHA-256 instructions supported (requires CryptoPlugin to be loaded). 0, not implemented. 1, SHA256 instructions implemented. : [0x0..0x1]
cpu.cpu3.enable_crc32=0x0                             # (int   , init-time) default = '0x0'    : CRC32 instructions supported. 0, not implemented. 1, CRC32 instructions implemented. : [0x0..0x1]
cpu.cpu3.CRYPTODISABLE=0                              # (bool  , init-time) default = '0'      : Disable cryptographic features.
cpu.cpu3.max_code_cache_mb=0x100                      # (int   , init-time) default = '0x100'  : Maximum size of the simulation code cache (MiB). For platforms with more than 2 cores this limit will be scaled down. (e.g 1/8 for 16 or more cores) : [0x1..0x4000]
cpu.cpu3.force-fpsid=0                                # (bool  , init-time) default = '0'      : Override the FPSID value
cpu.cpu3.force-fpsid-value=0x0                        # (int   , init-time) default = '0x0'    : Value to override the FPSID value to : [0x0..0xFFFFFFFF]
cpu.cpu3.number-of-breakpoints=0x10                   # (int   , init-time) default = '0x10'   : Number of breakpoints. : [0x2..0x10]
cpu.cpu3.number-of-watchpoints=0x10                   # (int   , init-time) default = '0x10'   : Number of watchpoints. : [0x2..0x10]
cpu.cpu3.number-of-context-breakpoints=0x10           # (int   , init-time) default = '0x10'   : Number of breakpoints that are context aware. : [0x0..0x10]
cpu.cpu3.DCZID-log2-block-size=0x8                    # (int   , init-time) default = '0x8'    : Log2 of the block size cleared by DC ZVA instruction (as read from DCZID_EL0). : [0x0..0x9]
cpu.cpu3.DCZVA_single_write=0                         # (bool  , init-time) default = '0'      : Execute the DCZVA as a single write
cpu.cpu3.unpredictable_WPMASKANDBAS=0x1               # (int   , init-time) default = '0x1'    : Constrained unpredictable handling of watchpoints when mask and BAS fields specified. 0, IGNOREMASK. 1, IGNOREBAS (default). 2, REPEATBAS8. 3, REPEATBAS. : [0x0..0x3]
cpu.cpu3.has_hcptr_tase=1                             # (bool  , init-time) default = '1'      : If false, HCPTR.TASE is RES0
cpu.cpu3.MPIDR-override=0x0                           # (int   , init-time) default = '0x0'    : Override of MPIDR value.  If nonzero will override the MT, cluster and CPU ID bits in MPIDR. : [0x0..0xFFFFFFFFFF]
cpu.cpu3.clock_divider=0x1                            # (int   , run-time ) default = '0x1'    : Clock divider ratio for asymmetric MP clocking. : [0x1..0xFFFFFFFF]
cpu.cpu3.clock_multiplier=0x1                         # (int   , run-time ) default = '0x1'    : Clock divider ratio for asymmetric MP clocking. : [0x1..0xFFFFFFFF]
cpu.cpu4.crypto_sha512=0x0                            # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SHA-512 instructions (requires CryptoPlugin to be loaded).

Possible values of this parameter are:
  - 0, feature is not enabled.
  - 1, feature is implemented if ARMv8.4 is enabled.
  - 2, feature is implemented. : [0x0..0x2]
cpu.cpu4.crypto_sha3=0x0                              # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SHA-3 instructions (requires CryptoPlugin to be loaded).

Possible values of this parameter are:
  - 0, feature is not enabled.
  - 1, feature is implemented if ARMv8.4 is enabled.
  - 2, feature is implemented. : [0x0..0x2]
cpu.cpu4.crypto_sm3=0x0                               # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SM-3 instructions (requires CryptoPlugin to be loaded).

Possible values of this parameter are:
  - 0, feature is not enabled.
  - 1, feature is implemented if ARMv8.4 is enabled.
  - 2, feature is implemented. : [0x0..0x2]
cpu.cpu4.crypto_sm4=0x0                               # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SM-4 instructions (requires CryptoPlugin to be loaded).

Possible values of this parameter are:
  - 0, feature is not enabled.
  - 1, feature is implemented if ARMv8.4 is enabled.
  - 2, feature is implemented. : [0x0..0x2]
cpu.cpu4.operation_bandwidth=0x1                      # (int   , init-time) default = '0x1'    : Operation width for ARMv8.4 PMU extension : [0x0..0xFF]
cpu.cpu4.vfp-present=1                                # (bool  , init-time) default = '1'      : Set whether the model has VFP support
cpu.cpu4.ase-present=1                                # (bool  , init-time) default = '1'      : Set whether the model has been built with NEON support
cpu.cpu4.etm-present=1                                # (bool  , init-time) default = '1'      : Set whether the model has ETM support
cpu.cpu4.SMPnAMP=1                                    # (bool  , init-time) default = '1'      : Enable broadcast messages necessary for correct SMP operation at reset.
cpu.cpu4.vfp-enable_at_reset=0                        # (bool  , init-time) default = '0'      : Enable VFP in CPACR, CPPWR, NSACR at reset. Warning: Arm recommends going through the implementation's suggested VFP power-up sequence!
cpu.cpu4.semihosting-enable=0                         # (bool  , init-time) default = '0'      : 
cpu.cpu4.semihosting-ARM_SVC=0x123456                 # (int   , init-time) default = '0x123456' : A32 SVC number for semihosting calls. : [0x0..0xFFFFFF]
cpu.cpu4.semihosting-Thumb_SVC=0xAB                   # (int   , init-time) default = '0xAB'   : T32 SVC number for semihosting calls. : [0x0..0xFF]
cpu.cpu4.semihosting-A64_HLT=0xF000                   # (int   , init-time) default = '0xF000' : A64 HLT number for semihosting calls. : [0x0..0xFFFF]
cpu.cpu4.semihosting-A32_HLT=0xF000                   # (int   , init-time) default = '0xF000' : A32 HLT number for semihosting calls. : [0x0..0xFFFF]
cpu.cpu4.semihosting-T32_HLT=0x3C                     # (int   , init-time) default = '0x3C'   : T32 HLT number for semihosting calls. : [0x0..0x3F]
cpu.cpu4.semihosting-cmd_line=""                      # (string, init-time) default = ''       : Command line available to semihosting calls.
cpu.cpu4.semihosting-heap_base=0x0                    # (int   , init-time) default = '0x0'    : Virtual address of heap base.
cpu.cpu4.semihosting-heap_limit=0xF000000             # (int   , init-time) default = '0xF000000' : Virtual address of top of heap.
cpu.cpu4.semihosting-stack_base=0x10000000            # (int   , init-time) default = '0x10000000' : Virtual address of base of descending stack.
cpu.cpu4.semihosting-stack_limit=0xF000000            # (int   , init-time) default = '0xF000000' : Virtual address of stack limit.
cpu.cpu4.semihosting-cwd=""                           # (string, init-time) default = ''       : Base directory for semihosting file access.
cpu.cpu4.semihosting-use_stderr=0                     # (bool  , init-time) default = '0'      : Send stderr from the simulated process to host stderr
cpu.cpu4.semihosting-stdin_istty=1                    # (bool  , init-time) default = '1'      : Result for semihost istty call when argument is stdin
cpu.cpu4.semihosting-stdout_istty=1                   # (bool  , init-time) default = '1'      : Result for semihost istty call when argument is stdout
cpu.cpu4.semihosting-stderr_istty=1                   # (bool  , init-time) default = '1'      : Result for semihost istty call when argument is stderr
cpu.cpu4.semihosting-prefix=0                         # (bool  , init-time) default = '0'      : Prefix semihosting output with target instance name
cpu.cpu4.enable_trace_special_hlt_imm16=0             # (bool  , init-time) default = '0'      : Enable usage of parameter trace_special_hlt_imm16
cpu.cpu4.trace_special_hlt_imm16=0xF000               # (int   , init-time) default = '0xF000' : For this HLT number, IF enable_trace_special_hlt_imm16=true, skip performing usual HLT execution but call MTI trace if registered : [0x0..0xFFFF]
cpu.cpu4.RVBAR=0x0                                    # (int   , init-time) default = '0x0'    : Value of RVBAR_ELx register. : [0x0..0xFFFFFFFFFFFC]
cpu.cpu4.vfp-traps=1                                  # (bool  , init-time) default = '1'      : Implement support for trapping floating-point exceptions
cpu.cpu4.vfp-traps-show-all=0                         # (bool  , init-time) default = '0'      : Report all trapped floating-point exceptions in the syndrome when a combination occurs.
cpu.cpu4.min_sync_level=0x0                           # (int   , run-time ) default = '0x0'    : Force minimum syncLevel (0=off=default,1=syncState,2=postInsnIO,3=postInsnAll) : [0x0..0x3]
cpu.cpu4.cti-number_of_triggers=0x8                   # (int   , init-time) default = '0x8'    : Number of cti event triggers : [0x0..0x8]
cpu.cpu4.cti-intack_mask=0x1                          # (int   , init-time) default = '0x1'    : Set bits represent that the corresponding trigger requires software acknowledge via CTIINTACK : [0x0..0xFF]
cpu.cpu4.cti-number_of_claim_bits=0x0                 # (int   , init-time) default = '0x0'    : Number of implemented bits in CTICLAIMSET : [0x0..0x1F]
cpu.cpu4.crypto_aes=0x2                               # (int   , init-time) default = '0x2'    : AES instructions supported (requires CryptoPlugin to be loaded). 0, not implemented. 1, AES instructions implemented. 2, AES and PMULL instructions implemented. : [0x0..0x2]
cpu.cpu4.crypto_sha1=0x1                              # (int   , init-time) default = '0x1'    : SHA-1 instructions supported (requires CryptoPlugin to be loaded). 0, not implemented. 1, SHA1 instructions implemented. : [0x0..0x1]
cpu.cpu4.crypto_sha256=0x1                            # (int   , init-time) default = '0x1'    : SHA-256 instructions supported (requires CryptoPlugin to be loaded). 0, not implemented. 1, SHA256 instructions implemented. : [0x0..0x1]
cpu.cpu4.enable_crc32=0x0                             # (int   , init-time) default = '0x0'    : CRC32 instructions supported. 0, not implemented. 1, CRC32 instructions implemented. : [0x0..0x1]
cpu.cpu4.CRYPTODISABLE=0                              # (bool  , init-time) default = '0'      : Disable cryptographic features.
cpu.cpu4.max_code_cache_mb=0x100                      # (int   , init-time) default = '0x100'  : Maximum size of the simulation code cache (MiB). For platforms with more than 2 cores this limit will be scaled down. (e.g 1/8 for 16 or more cores) : [0x1..0x4000]
cpu.cpu4.force-fpsid=0                                # (bool  , init-time) default = '0'      : Override the FPSID value
cpu.cpu4.force-fpsid-value=0x0                        # (int   , init-time) default = '0x0'    : Value to override the FPSID value to : [0x0..0xFFFFFFFF]
cpu.cpu4.number-of-breakpoints=0x10                   # (int   , init-time) default = '0x10'   : Number of breakpoints. : [0x2..0x10]
cpu.cpu4.number-of-watchpoints=0x10                   # (int   , init-time) default = '0x10'   : Number of watchpoints. : [0x2..0x10]
cpu.cpu4.number-of-context-breakpoints=0x10           # (int   , init-time) default = '0x10'   : Number of breakpoints that are context aware. : [0x0..0x10]
cpu.cpu4.DCZID-log2-block-size=0x8                    # (int   , init-time) default = '0x8'    : Log2 of the block size cleared by DC ZVA instruction (as read from DCZID_EL0). : [0x0..0x9]
cpu.cpu4.DCZVA_single_write=0                         # (bool  , init-time) default = '0'      : Execute the DCZVA as a single write
cpu.cpu4.unpredictable_WPMASKANDBAS=0x1               # (int   , init-time) default = '0x1'    : Constrained unpredictable handling of watchpoints when mask and BAS fields specified. 0, IGNOREMASK. 1, IGNOREBAS (default). 2, REPEATBAS8. 3, REPEATBAS. : [0x0..0x3]
cpu.cpu4.has_hcptr_tase=1                             # (bool  , init-time) default = '1'      : If false, HCPTR.TASE is RES0
cpu.cpu4.MPIDR-override=0x0                           # (int   , init-time) default = '0x0'    : Override of MPIDR value.  If nonzero will override the MT, cluster and CPU ID bits in MPIDR. : [0x0..0xFFFFFFFFFF]
cpu.cpu4.clock_divider=0x1                            # (int   , run-time ) default = '0x1'    : Clock divider ratio for asymmetric MP clocking. : [0x1..0xFFFFFFFF]
cpu.cpu4.clock_multiplier=0x1                         # (int   , run-time ) default = '0x1'    : Clock divider ratio for asymmetric MP clocking. : [0x1..0xFFFFFFFF]
cpu.cpu5.crypto_sha512=0x0                            # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SHA-512 instructions (requires CryptoPlugin to be loaded).

Possible values of this parameter are:
  - 0, feature is not enabled.
  - 1, feature is implemented if ARMv8.4 is enabled.
  - 2, feature is implemented. : [0x0..0x2]
cpu.cpu5.crypto_sha3=0x0                              # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SHA-3 instructions (requires CryptoPlugin to be loaded).

Possible values of this parameter are:
  - 0, feature is not enabled.
  - 1, feature is implemented if ARMv8.4 is enabled.
  - 2, feature is implemented. : [0x0..0x2]
cpu.cpu5.crypto_sm3=0x0                               # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SM-3 instructions (requires CryptoPlugin to be loaded).

Possible values of this parameter are:
  - 0, feature is not enabled.
  - 1, feature is implemented if ARMv8.4 is enabled.
  - 2, feature is implemented. : [0x0..0x2]
cpu.cpu5.crypto_sm4=0x0                               # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SM-4 instructions (requires CryptoPlugin to be loaded).

Possible values of this parameter are:
  - 0, feature is not enabled.
  - 1, feature is implemented if ARMv8.4 is enabled.
  - 2, feature is implemented. : [0x0..0x2]
cpu.cpu5.operation_bandwidth=0x1                      # (int   , init-time) default = '0x1'    : Operation width for ARMv8.4 PMU extension : [0x0..0xFF]
cpu.cpu5.vfp-present=1                                # (bool  , init-time) default = '1'      : Set whether the model has VFP support
cpu.cpu5.ase-present=1                                # (bool  , init-time) default = '1'      : Set whether the model has been built with NEON support
cpu.cpu5.etm-present=1                                # (bool  , init-time) default = '1'      : Set whether the model has ETM support
cpu.cpu5.SMPnAMP=1                                    # (bool  , init-time) default = '1'      : Enable broadcast messages necessary for correct SMP operation at reset.
cpu.cpu5.vfp-enable_at_reset=0                        # (bool  , init-time) default = '0'      : Enable VFP in CPACR, CPPWR, NSACR at reset. Warning: Arm recommends going through the implementation's suggested VFP power-up sequence!
cpu.cpu5.semihosting-enable=0                         # (bool  , init-time) default = '0'      : 
cpu.cpu5.semihosting-ARM_SVC=0x123456                 # (int   , init-time) default = '0x123456' : A32 SVC number for semihosting calls. : [0x0..0xFFFFFF]
cpu.cpu5.semihosting-Thumb_SVC=0xAB                   # (int   , init-time) default = '0xAB'   : T32 SVC number for semihosting calls. : [0x0..0xFF]
cpu.cpu5.semihosting-A64_HLT=0xF000                   # (int   , init-time) default = '0xF000' : A64 HLT number for semihosting calls. : [0x0..0xFFFF]
cpu.cpu5.semihosting-A32_HLT=0xF000                   # (int   , init-time) default = '0xF000' : A32 HLT number for semihosting calls. : [0x0..0xFFFF]
cpu.cpu5.semihosting-T32_HLT=0x3C                     # (int   , init-time) default = '0x3C'   : T32 HLT number for semihosting calls. : [0x0..0x3F]
cpu.cpu5.semihosting-cmd_line=""                      # (string, init-time) default = ''       : Command line available to semihosting calls.
cpu.cpu5.semihosting-heap_base=0x0                    # (int   , init-time) default = '0x0'    : Virtual address of heap base.
cpu.cpu5.semihosting-heap_limit=0xF000000             # (int   , init-time) default = '0xF000000' : Virtual address of top of heap.
cpu.cpu5.semihosting-stack_base=0x10000000            # (int   , init-time) default = '0x10000000' : Virtual address of base of descending stack.
cpu.cpu5.semihosting-stack_limit=0xF000000            # (int   , init-time) default = '0xF000000' : Virtual address of stack limit.
cpu.cpu5.semihosting-cwd=""                           # (string, init-time) default = ''       : Base directory for semihosting file access.
cpu.cpu5.semihosting-use_stderr=0                     # (bool  , init-time) default = '0'      : Send stderr from the simulated process to host stderr
cpu.cpu5.semihosting-stdin_istty=1                    # (bool  , init-time) default = '1'      : Result for semihost istty call when argument is stdin
cpu.cpu5.semihosting-stdout_istty=1                   # (bool  , init-time) default = '1'      : Result for semihost istty call when argument is stdout
cpu.cpu5.semihosting-stderr_istty=1                   # (bool  , init-time) default = '1'      : Result for semihost istty call when argument is stderr
cpu.cpu5.semihosting-prefix=0                         # (bool  , init-time) default = '0'      : Prefix semihosting output with target instance name
cpu.cpu5.enable_trace_special_hlt_imm16=0             # (bool  , init-time) default = '0'      : Enable usage of parameter trace_special_hlt_imm16
cpu.cpu5.trace_special_hlt_imm16=0xF000               # (int   , init-time) default = '0xF000' : For this HLT number, IF enable_trace_special_hlt_imm16=true, skip performing usual HLT execution but call MTI trace if registered : [0x0..0xFFFF]
cpu.cpu5.RVBAR=0x0                                    # (int   , init-time) default = '0x0'    : Value of RVBAR_ELx register. : [0x0..0xFFFFFFFFFFFC]
cpu.cpu5.vfp-traps=1                                  # (bool  , init-time) default = '1'      : Implement support for trapping floating-point exceptions
cpu.cpu5.vfp-traps-show-all=0                         # (bool  , init-time) default = '0'      : Report all trapped floating-point exceptions in the syndrome when a combination occurs.
cpu.cpu5.min_sync_level=0x0                           # (int   , run-time ) default = '0x0'    : Force minimum syncLevel (0=off=default,1=syncState,2=postInsnIO,3=postInsnAll) : [0x0..0x3]
cpu.cpu5.cti-number_of_triggers=0x8                   # (int   , init-time) default = '0x8'    : Number of cti event triggers : [0x0..0x8]
cpu.cpu5.cti-intack_mask=0x1                          # (int   , init-time) default = '0x1'    : Set bits represent that the corresponding trigger requires software acknowledge via CTIINTACK : [0x0..0xFF]
cpu.cpu5.cti-number_of_claim_bits=0x0                 # (int   , init-time) default = '0x0'    : Number of implemented bits in CTICLAIMSET : [0x0..0x1F]
cpu.cpu5.crypto_aes=0x2                               # (int   , init-time) default = '0x2'    : AES instructions supported (requires CryptoPlugin to be loaded). 0, not implemented. 1, AES instructions implemented. 2, AES and PMULL instructions implemented. : [0x0..0x2]
cpu.cpu5.crypto_sha1=0x1                              # (int   , init-time) default = '0x1'    : SHA-1 instructions supported (requires CryptoPlugin to be loaded). 0, not implemented. 1, SHA1 instructions implemented. : [0x0..0x1]
cpu.cpu5.crypto_sha256=0x1                            # (int   , init-time) default = '0x1'    : SHA-256 instructions supported (requires CryptoPlugin to be loaded). 0, not implemented. 1, SHA256 instructions implemented. : [0x0..0x1]
cpu.cpu5.enable_crc32=0x0                             # (int   , init-time) default = '0x0'    : CRC32 instructions supported. 0, not implemented. 1, CRC32 instructions implemented. : [0x0..0x1]
cpu.cpu5.CRYPTODISABLE=0                              # (bool  , init-time) default = '0'      : Disable cryptographic features.
cpu.cpu5.max_code_cache_mb=0x100                      # (int   , init-time) default = '0x100'  : Maximum size of the simulation code cache (MiB). For platforms with more than 2 cores this limit will be scaled down. (e.g 1/8 for 16 or more cores) : [0x1..0x4000]
cpu.cpu5.force-fpsid=0                                # (bool  , init-time) default = '0'      : Override the FPSID value
cpu.cpu5.force-fpsid-value=0x0                        # (int   , init-time) default = '0x0'    : Value to override the FPSID value to : [0x0..0xFFFFFFFF]
cpu.cpu5.number-of-breakpoints=0x10                   # (int   , init-time) default = '0x10'   : Number of breakpoints. : [0x2..0x10]
cpu.cpu5.number-of-watchpoints=0x10                   # (int   , init-time) default = '0x10'   : Number of watchpoints. : [0x2..0x10]
cpu.cpu5.number-of-context-breakpoints=0x10           # (int   , init-time) default = '0x10'   : Number of breakpoints that are context aware. : [0x0..0x10]
cpu.cpu5.DCZID-log2-block-size=0x8                    # (int   , init-time) default = '0x8'    : Log2 of the block size cleared by DC ZVA instruction (as read from DCZID_EL0). : [0x0..0x9]
cpu.cpu5.DCZVA_single_write=0                         # (bool  , init-time) default = '0'      : Execute the DCZVA as a single write
cpu.cpu5.unpredictable_WPMASKANDBAS=0x1               # (int   , init-time) default = '0x1'    : Constrained unpredictable handling of watchpoints when mask and BAS fields specified. 0, IGNOREMASK. 1, IGNOREBAS (default). 2, REPEATBAS8. 3, REPEATBAS. : [0x0..0x3]
cpu.cpu5.has_hcptr_tase=1                             # (bool  , init-time) default = '1'      : If false, HCPTR.TASE is RES0
cpu.cpu5.MPIDR-override=0x0                           # (int   , init-time) default = '0x0'    : Override of MPIDR value.  If nonzero will override the MT, cluster and CPU ID bits in MPIDR. : [0x0..0xFFFFFFFFFF]
cpu.cpu5.clock_divider=0x1                            # (int   , run-time ) default = '0x1'    : Clock divider ratio for asymmetric MP clocking. : [0x1..0xFFFFFFFF]
cpu.cpu5.clock_multiplier=0x1                         # (int   , run-time ) default = '0x1'    : Clock divider ratio for asymmetric MP clocking. : [0x1..0xFFFFFFFF]
cpu.cpu6.crypto_sha512=0x0                            # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SHA-512 instructions (requires CryptoPlugin to be loaded).

Possible values of this parameter are:
  - 0, feature is not enabled.
  - 1, feature is implemented if ARMv8.4 is enabled.
  - 2, feature is implemented. : [0x0..0x2]
cpu.cpu6.crypto_sha3=0x0                              # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SHA-3 instructions (requires CryptoPlugin to be loaded).

Possible values of this parameter are:
  - 0, feature is not enabled.
  - 1, feature is implemented if ARMv8.4 is enabled.
  - 2, feature is implemented. : [0x0..0x2]
cpu.cpu6.crypto_sm3=0x0                               # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SM-3 instructions (requires CryptoPlugin to be loaded).

Possible values of this parameter are:
  - 0, feature is not enabled.
  - 1, feature is implemented if ARMv8.4 is enabled.
  - 2, feature is implemented. : [0x0..0x2]
cpu.cpu6.crypto_sm4=0x0                               # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SM-4 instructions (requires CryptoPlugin to be loaded).

Possible values of this parameter are:
  - 0, feature is not enabled.
  - 1, feature is implemented if ARMv8.4 is enabled.
  - 2, feature is implemented. : [0x0..0x2]
cpu.cpu6.operation_bandwidth=0x1                      # (int   , init-time) default = '0x1'    : Operation width for ARMv8.4 PMU extension : [0x0..0xFF]
cpu.cpu6.vfp-present=1                                # (bool  , init-time) default = '1'      : Set whether the model has VFP support
cpu.cpu6.ase-present=1                                # (bool  , init-time) default = '1'      : Set whether the model has been built with NEON support
cpu.cpu6.etm-present=1                                # (bool  , init-time) default = '1'      : Set whether the model has ETM support
cpu.cpu6.SMPnAMP=1                                    # (bool  , init-time) default = '1'      : Enable broadcast messages necessary for correct SMP operation at reset.
cpu.cpu6.vfp-enable_at_reset=0                        # (bool  , init-time) default = '0'      : Enable VFP in CPACR, CPPWR, NSACR at reset. Warning: Arm recommends going through the implementation's suggested VFP power-up sequence!
cpu.cpu6.semihosting-enable=0                         # (bool  , init-time) default = '0'      : 
cpu.cpu6.semihosting-ARM_SVC=0x123456                 # (int   , init-time) default = '0x123456' : A32 SVC number for semihosting calls. : [0x0..0xFFFFFF]
cpu.cpu6.semihosting-Thumb_SVC=0xAB                   # (int   , init-time) default = '0xAB'   : T32 SVC number for semihosting calls. : [0x0..0xFF]
cpu.cpu6.semihosting-A64_HLT=0xF000                   # (int   , init-time) default = '0xF000' : A64 HLT number for semihosting calls. : [0x0..0xFFFF]
cpu.cpu6.semihosting-A32_HLT=0xF000                   # (int   , init-time) default = '0xF000' : A32 HLT number for semihosting calls. : [0x0..0xFFFF]
cpu.cpu6.semihosting-T32_HLT=0x3C                     # (int   , init-time) default = '0x3C'   : T32 HLT number for semihosting calls. : [0x0..0x3F]
cpu.cpu6.semihosting-cmd_line=""                      # (string, init-time) default = ''       : Command line available to semihosting calls.
cpu.cpu6.semihosting-heap_base=0x0                    # (int   , init-time) default = '0x0'    : Virtual address of heap base.
cpu.cpu6.semihosting-heap_limit=0xF000000             # (int   , init-time) default = '0xF000000' : Virtual address of top of heap.
cpu.cpu6.semihosting-stack_base=0x10000000            # (int   , init-time) default = '0x10000000' : Virtual address of base of descending stack.
cpu.cpu6.semihosting-stack_limit=0xF000000            # (int   , init-time) default = '0xF000000' : Virtual address of stack limit.
cpu.cpu6.semihosting-cwd=""                           # (string, init-time) default = ''       : Base directory for semihosting file access.
cpu.cpu6.semihosting-use_stderr=0                     # (bool  , init-time) default = '0'      : Send stderr from the simulated process to host stderr
cpu.cpu6.semihosting-stdin_istty=1                    # (bool  , init-time) default = '1'      : Result for semihost istty call when argument is stdin
cpu.cpu6.semihosting-stdout_istty=1                   # (bool  , init-time) default = '1'      : Result for semihost istty call when argument is stdout
cpu.cpu6.semihosting-stderr_istty=1                   # (bool  , init-time) default = '1'      : Result for semihost istty call when argument is stderr
cpu.cpu6.semihosting-prefix=0                         # (bool  , init-time) default = '0'      : Prefix semihosting output with target instance name
cpu.cpu6.enable_trace_special_hlt_imm16=0             # (bool  , init-time) default = '0'      : Enable usage of parameter trace_special_hlt_imm16
cpu.cpu6.trace_special_hlt_imm16=0xF000               # (int   , init-time) default = '0xF000' : For this HLT number, IF enable_trace_special_hlt_imm16=true, skip performing usual HLT execution but call MTI trace if registered : [0x0..0xFFFF]
cpu.cpu6.RVBAR=0x0                                    # (int   , init-time) default = '0x0'    : Value of RVBAR_ELx register. : [0x0..0xFFFFFFFFFFFC]
cpu.cpu6.vfp-traps=1                                  # (bool  , init-time) default = '1'      : Implement support for trapping floating-point exceptions
cpu.cpu6.vfp-traps-show-all=0                         # (bool  , init-time) default = '0'      : Report all trapped floating-point exceptions in the syndrome when a combination occurs.
cpu.cpu6.min_sync_level=0x0                           # (int   , run-time ) default = '0x0'    : Force minimum syncLevel (0=off=default,1=syncState,2=postInsnIO,3=postInsnAll) : [0x0..0x3]
cpu.cpu6.cti-number_of_triggers=0x8                   # (int   , init-time) default = '0x8'    : Number of cti event triggers : [0x0..0x8]
cpu.cpu6.cti-intack_mask=0x1                          # (int   , init-time) default = '0x1'    : Set bits represent that the corresponding trigger requires software acknowledge via CTIINTACK : [0x0..0xFF]
cpu.cpu6.cti-number_of_claim_bits=0x0                 # (int   , init-time) default = '0x0'    : Number of implemented bits in CTICLAIMSET : [0x0..0x1F]
cpu.cpu6.crypto_aes=0x2                               # (int   , init-time) default = '0x2'    : AES instructions supported (requires CryptoPlugin to be loaded). 0, not implemented. 1, AES instructions implemented. 2, AES and PMULL instructions implemented. : [0x0..0x2]
cpu.cpu6.crypto_sha1=0x1                              # (int   , init-time) default = '0x1'    : SHA-1 instructions supported (requires CryptoPlugin to be loaded). 0, not implemented. 1, SHA1 instructions implemented. : [0x0..0x1]
cpu.cpu6.crypto_sha256=0x1                            # (int   , init-time) default = '0x1'    : SHA-256 instructions supported (requires CryptoPlugin to be loaded). 0, not implemented. 1, SHA256 instructions implemented. : [0x0..0x1]
cpu.cpu6.enable_crc32=0x0                             # (int   , init-time) default = '0x0'    : CRC32 instructions supported. 0, not implemented. 1, CRC32 instructions implemented. : [0x0..0x1]
cpu.cpu6.CRYPTODISABLE=0                              # (bool  , init-time) default = '0'      : Disable cryptographic features.
cpu.cpu6.max_code_cache_mb=0x100                      # (int   , init-time) default = '0x100'  : Maximum size of the simulation code cache (MiB). For platforms with more than 2 cores this limit will be scaled down. (e.g 1/8 for 16 or more cores) : [0x1..0x4000]
cpu.cpu6.force-fpsid=0                                # (bool  , init-time) default = '0'      : Override the FPSID value
cpu.cpu6.force-fpsid-value=0x0                        # (int   , init-time) default = '0x0'    : Value to override the FPSID value to : [0x0..0xFFFFFFFF]
cpu.cpu6.number-of-breakpoints=0x10                   # (int   , init-time) default = '0x10'   : Number of breakpoints. : [0x2..0x10]
cpu.cpu6.number-of-watchpoints=0x10                   # (int   , init-time) default = '0x10'   : Number of watchpoints. : [0x2..0x10]
cpu.cpu6.number-of-context-breakpoints=0x10           # (int   , init-time) default = '0x10'   : Number of breakpoints that are context aware. : [0x0..0x10]
cpu.cpu6.DCZID-log2-block-size=0x8                    # (int   , init-time) default = '0x8'    : Log2 of the block size cleared by DC ZVA instruction (as read from DCZID_EL0). : [0x0..0x9]
cpu.cpu6.DCZVA_single_write=0                         # (bool  , init-time) default = '0'      : Execute the DCZVA as a single write
cpu.cpu6.unpredictable_WPMASKANDBAS=0x1               # (int   , init-time) default = '0x1'    : Constrained unpredictable handling of watchpoints when mask and BAS fields specified. 0, IGNOREMASK. 1, IGNOREBAS (default). 2, REPEATBAS8. 3, REPEATBAS. : [0x0..0x3]
cpu.cpu6.has_hcptr_tase=1                             # (bool  , init-time) default = '1'      : If false, HCPTR.TASE is RES0
cpu.cpu6.MPIDR-override=0x0                           # (int   , init-time) default = '0x0'    : Override of MPIDR value.  If nonzero will override the MT, cluster and CPU ID bits in MPIDR. : [0x0..0xFFFFFFFFFF]
cpu.cpu6.clock_divider=0x1                            # (int   , run-time ) default = '0x1'    : Clock divider ratio for asymmetric MP clocking. : [0x1..0xFFFFFFFF]
cpu.cpu6.clock_multiplier=0x1                         # (int   , run-time ) default = '0x1'    : Clock divider ratio for asymmetric MP clocking. : [0x1..0xFFFFFFFF]
cpu.cpu7.crypto_sha512=0x0                            # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SHA-512 instructions (requires CryptoPlugin to be loaded).

Possible values of this parameter are:
  - 0, feature is not enabled.
  - 1, feature is implemented if ARMv8.4 is enabled.
  - 2, feature is implemented. : [0x0..0x2]
cpu.cpu7.crypto_sha3=0x0                              # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SHA-3 instructions (requires CryptoPlugin to be loaded).

Possible values of this parameter are:
  - 0, feature is not enabled.
  - 1, feature is implemented if ARMv8.4 is enabled.
  - 2, feature is implemented. : [0x0..0x2]
cpu.cpu7.crypto_sm3=0x0                               # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SM-3 instructions (requires CryptoPlugin to be loaded).

Possible values of this parameter are:
  - 0, feature is not enabled.
  - 1, feature is implemented if ARMv8.4 is enabled.
  - 2, feature is implemented. : [0x0..0x2]
cpu.cpu7.crypto_sm4=0x0                               # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SM-4 instructions (requires CryptoPlugin to be loaded).

Possible values of this parameter are:
  - 0, feature is not enabled.
  - 1, feature is implemented if ARMv8.4 is enabled.
  - 2, feature is implemented. : [0x0..0x2]
cpu.cpu7.operation_bandwidth=0x1                      # (int   , init-time) default = '0x1'    : Operation width for ARMv8.4 PMU extension : [0x0..0xFF]
cpu.cpu7.vfp-present=1                                # (bool  , init-time) default = '1'      : Set whether the model has VFP support
cpu.cpu7.ase-present=1                                # (bool  , init-time) default = '1'      : Set whether the model has been built with NEON support
cpu.cpu7.etm-present=1                                # (bool  , init-time) default = '1'      : Set whether the model has ETM support
cpu.cpu7.SMPnAMP=1                                    # (bool  , init-time) default = '1'      : Enable broadcast messages necessary for correct SMP operation at reset.
cpu.cpu7.vfp-enable_at_reset=0                        # (bool  , init-time) default = '0'      : Enable VFP in CPACR, CPPWR, NSACR at reset. Warning: Arm recommends going through the implementation's suggested VFP power-up sequence!
cpu.cpu7.semihosting-enable=0                         # (bool  , init-time) default = '0'      : 
cpu.cpu7.semihosting-ARM_SVC=0x123456                 # (int   , init-time) default = '0x123456' : A32 SVC number for semihosting calls. : [0x0..0xFFFFFF]
cpu.cpu7.semihosting-Thumb_SVC=0xAB                   # (int   , init-time) default = '0xAB'   : T32 SVC number for semihosting calls. : [0x0..0xFF]
cpu.cpu7.semihosting-A64_HLT=0xF000                   # (int   , init-time) default = '0xF000' : A64 HLT number for semihosting calls. : [0x0..0xFFFF]
cpu.cpu7.semihosting-A32_HLT=0xF000                   # (int   , init-time) default = '0xF000' : A32 HLT number for semihosting calls. : [0x0..0xFFFF]
cpu.cpu7.semihosting-T32_HLT=0x3C                     # (int   , init-time) default = '0x3C'   : T32 HLT number for semihosting calls. : [0x0..0x3F]
cpu.cpu7.semihosting-cmd_line=""                      # (string, init-time) default = ''       : Command line available to semihosting calls.
cpu.cpu7.semihosting-heap_base=0x0                    # (int   , init-time) default = '0x0'    : Virtual address of heap base.
cpu.cpu7.semihosting-heap_limit=0xF000000             # (int   , init-time) default = '0xF000000' : Virtual address of top of heap.
cpu.cpu7.semihosting-stack_base=0x10000000            # (int   , init-time) default = '0x10000000' : Virtual address of base of descending stack.
cpu.cpu7.semihosting-stack_limit=0xF000000            # (int   , init-time) default = '0xF000000' : Virtual address of stack limit.
cpu.cpu7.semihosting-cwd=""                           # (string, init-time) default = ''       : Base directory for semihosting file access.
cpu.cpu7.semihosting-use_stderr=0                     # (bool  , init-time) default = '0'      : Send stderr from the simulated process to host stderr
cpu.cpu7.semihosting-stdin_istty=1                    # (bool  , init-time) default = '1'      : Result for semihost istty call when argument is stdin
cpu.cpu7.semihosting-stdout_istty=1                   # (bool  , init-time) default = '1'      : Result for semihost istty call when argument is stdout
cpu.cpu7.semihosting-stderr_istty=1                   # (bool  , init-time) default = '1'      : Result for semihost istty call when argument is stderr
cpu.cpu7.semihosting-prefix=0                         # (bool  , init-time) default = '0'      : Prefix semihosting output with target instance name
cpu.cpu7.enable_trace_special_hlt_imm16=0             # (bool  , init-time) default = '0'      : Enable usage of parameter trace_special_hlt_imm16
cpu.cpu7.trace_special_hlt_imm16=0xF000               # (int   , init-time) default = '0xF000' : For this HLT number, IF enable_trace_special_hlt_imm16=true, skip performing usual HLT execution but call MTI trace if registered : [0x0..0xFFFF]
cpu.cpu7.RVBAR=0x0                                    # (int   , init-time) default = '0x0'    : Value of RVBAR_ELx register. : [0x0..0xFFFFFFFFFFFC]
cpu.cpu7.vfp-traps=1                                  # (bool  , init-time) default = '1'      : Implement support for trapping floating-point exceptions
cpu.cpu7.vfp-traps-show-all=0                         # (bool  , init-time) default = '0'      : Report all trapped floating-point exceptions in the syndrome when a combination occurs.
cpu.cpu7.min_sync_level=0x0                           # (int   , run-time ) default = '0x0'    : Force minimum syncLevel (0=off=default,1=syncState,2=postInsnIO,3=postInsnAll) : [0x0..0x3]
cpu.cpu7.cti-number_of_triggers=0x8                   # (int   , init-time) default = '0x8'    : Number of cti event triggers : [0x0..0x8]
cpu.cpu7.cti-intack_mask=0x1                          # (int   , init-time) default = '0x1'    : Set bits represent that the corresponding trigger requires software acknowledge via CTIINTACK : [0x0..0xFF]
cpu.cpu7.cti-number_of_claim_bits=0x0                 # (int   , init-time) default = '0x0'    : Number of implemented bits in CTICLAIMSET : [0x0..0x1F]
cpu.cpu7.crypto_aes=0x2                               # (int   , init-time) default = '0x2'    : AES instructions supported (requires CryptoPlugin to be loaded). 0, not implemented. 1, AES instructions implemented. 2, AES and PMULL instructions implemented. : [0x0..0x2]
cpu.cpu7.crypto_sha1=0x1                              # (int   , init-time) default = '0x1'    : SHA-1 instructions supported (requires CryptoPlugin to be loaded). 0, not implemented. 1, SHA1 instructions implemented. : [0x0..0x1]
cpu.cpu7.crypto_sha256=0x1                            # (int   , init-time) default = '0x1'    : SHA-256 instructions supported (requires CryptoPlugin to be loaded). 0, not implemented. 1, SHA256 instructions implemented. : [0x0..0x1]
cpu.cpu7.enable_crc32=0x0                             # (int   , init-time) default = '0x0'    : CRC32 instructions supported. 0, not implemented. 1, CRC32 instructions implemented. : [0x0..0x1]
cpu.cpu7.CRYPTODISABLE=0                              # (bool  , init-time) default = '0'      : Disable cryptographic features.
cpu.cpu7.max_code_cache_mb=0x100                      # (int   , init-time) default = '0x100'  : Maximum size of the simulation code cache (MiB). For platforms with more than 2 cores this limit will be scaled down. (e.g 1/8 for 16 or more cores) : [0x1..0x4000]
cpu.cpu7.force-fpsid=0                                # (bool  , init-time) default = '0'      : Override the FPSID value
cpu.cpu7.force-fpsid-value=0x0                        # (int   , init-time) default = '0x0'    : Value to override the FPSID value to : [0x0..0xFFFFFFFF]
cpu.cpu7.number-of-breakpoints=0x10                   # (int   , init-time) default = '0x10'   : Number of breakpoints. : [0x2..0x10]
cpu.cpu7.number-of-watchpoints=0x10                   # (int   , init-time) default = '0x10'   : Number of watchpoints. : [0x2..0x10]
cpu.cpu7.number-of-context-breakpoints=0x10           # (int   , init-time) default = '0x10'   : Number of breakpoints that are context aware. : [0x0..0x10]
cpu.cpu7.DCZID-log2-block-size=0x8                    # (int   , init-time) default = '0x8'    : Log2 of the block size cleared by DC ZVA instruction (as read from DCZID_EL0). : [0x0..0x9]
cpu.cpu7.DCZVA_single_write=0                         # (bool  , init-time) default = '0'      : Execute the DCZVA as a single write
cpu.cpu7.unpredictable_WPMASKANDBAS=0x1               # (int   , init-time) default = '0x1'    : Constrained unpredictable handling of watchpoints when mask and BAS fields specified. 0, IGNOREMASK. 1, IGNOREBAS (default). 2, REPEATBAS8. 3, REPEATBAS. : [0x0..0x3]
cpu.cpu7.has_hcptr_tase=1                             # (bool  , init-time) default = '1'      : If false, HCPTR.TASE is RES0
cpu.cpu7.MPIDR-override=0x0                           # (int   , init-time) default = '0x0'    : Override of MPIDR value.  If nonzero will override the MT, cluster and CPU ID bits in MPIDR. : [0x0..0xFFFFFFFFFF]
cpu.cpu7.clock_divider=0x1                            # (int   , run-time ) default = '0x1'    : Clock divider ratio for asymmetric MP clocking. : [0x1..0xFFFFFFFF]
cpu.cpu7.clock_multiplier=0x1                         # (int   , run-time ) default = '0x1'    : Clock divider ratio for asymmetric MP clocking. : [0x1..0xFFFFFFFF]
atomic_op_filter.filter.handling_of_dvm_messages_from_upstream="forward"  # (string, init-time) default = 'forward' : What to do with DVM (Distributed Virtual Memory) messages received from upstream.  The options are to 'forward' them downstream unaltered, to 'terminate' them, or to 'handle' them locally and get called through handleUpstreamDVMMessage()
atomic_op_filter.filter.handling_of_dvm_messages_from_downstream="forward"  # (string, init-time) default = 'forward' : What to do with DVM (Distributed Virtual Memory) messages received from downstream.  The options are to 'forward' them upstream unaltered, to 'terminate' them, or to 'handle' them locally and get called through handleDownstreamDVMMessage()
atomic_op_filter.filter.handling_of_upstream_snoop_requests="forward"  # (string, init-time) default = 'forward' : What to do with snoop requests from downstream.  The options are to 'forward', 'terminate' or 'handle'.  NOTE that currently the snoop request addresses are _not_ translated and so if your device alters the address translation then you will almost certainly want to 'terminate'.
busfilter.register_base=0x0                           # (int   , init-time) default = '0x0'    : Base address of trickbox registers
busfilter.log2_register_size=0x0                      # (int   , init-time) default = '0x0'    : Log2 size of trickbox register block (zero disables address decoder)
busfilter.num_reg_blocks=0x1                          # (int   , init-time) default = '0x1'    : Number of register-blocks. : [0x1..0x4]
busfilter.disable_address_filter=0                    # (bool  , run-time ) default = '0'      : Skip the trickbox filter, disabling all address checking
busfilter.filter.handling_of_dvm_messages_from_upstream="forward"  # (string, init-time) default = 'forward' : What to do with DVM (Distributed Virtual Memory) messages received from upstream.  The options are to 'forward' them downstream unaltered, to 'terminate' them, or to 'handle' them locally and get called through handleUpstreamDVMMessage()
busfilter.filter.handling_of_dvm_messages_from_downstream="forward"  # (string, init-time) default = 'forward' : What to do with DVM (Distributed Virtual Memory) messages received from downstream.  The options are to 'forward' them upstream unaltered, to 'terminate' them, or to 'handle' them locally and get called through handleDownstreamDVMMessage()
busfilter.filter.handling_of_upstream_snoop_requests="forward"  # (string, init-time) default = 'forward' : What to do with snoop requests from downstream.  The options are to 'forward', 'terminate' or 'handle'.  NOTE that currently the snoop request addresses are _not_ translated and so if your device alters the address translation then you will almost certainly want to 'terminate'.
busfilter.forward.handling_of_dvm_messages_from_upstream="forward"  # (string, init-time) default = 'forward' : What to do with DVM (Distributed Virtual Memory) messages received from upstream.  The options are to 'forward' them downstream unaltered, to 'terminate' them, or to 'handle' them locally and get called through handleUpstreamDVMMessage()
busfilter.forward.handling_of_dvm_messages_from_downstream="forward"  # (string, init-time) default = 'forward' : What to do with DVM (Distributed Virtual Memory) messages received from downstream.  The options are to 'forward' them upstream unaltered, to 'terminate' them, or to 'handle' them locally and get called through handleDownstreamDVMMessage()
busfilter.forward.handling_of_upstream_snoop_requests="forward"  # (string, init-time) default = 'forward' : What to do with snoop requests from downstream.  The options are to 'forward', 'terminate' or 'handle'.  NOTE that currently the snoop request addresses are _not_ translated and so if your device alters the address translation then you will almost certainly want to 'terminate'.
exclusive_monitor.enable_component=1                  # (bool  , init-time) default = '1'      : Enable component
exclusive_monitor.number_of_monitors=0x8              # (int   , init-time) default = '0x8'    : Number of monitors : [0x1..0xFFFFFFFF]
exclusive_monitor.log2_granule_size=0x0               # (int   , init-time) default = '0x0'    : log2 of address granule size : [0x0..0xB]
exclusive_monitor.match_access_width=0                # (bool  , init-time) default = '0'      : Fail STREX if not the same access width as LDREX
exclusive_monitor.monitor_non_excl_stores=0           # (bool  , init-time) default = '0'      : Monitor non-exclusive stores from the same master
exclusive_monitor.match_secure_state=1                # (bool  , init-time) default = '1'      : Treat the secure state like an address bit
exclusive_monitor.shareability_domain=0x3             # (int   , init-time) default = '0x3'    : Maximum shareability domain of interest, transactions outside of the domain will pass through un-monitored (0-non-shared, 1-inner, 2-outer, 3-system) : [0x0..0x3]
exclusive_monitor.apply_access_width_criteria_to_non_excl_stores=1  # (bool  , init-time) default = '1'      : Apply the given exclusive store width matching criteria to non-exclusive stores
exclusive_monitor.clear_on_strex_address_mismatch=1   # (bool  , init-time) default = '1'      : Whether monitor is cleared when strex fails due to address mismatch
sdram0.unknown_tracking=0                             # (bool  , init-time) default = '0'      : Perform UNKNOWN tracking
sdram0.enable_atomic_ops=0                            # (bool  , init-time) default = '0'      : Supports Atomic Operations
sdram1.unknown_tracking=0                             # (bool  , init-time) default = '0'      : Perform UNKNOWN tracking
sdram1.enable_atomic_ops=0                            # (bool  , init-time) default = '0'      : Supports Atomic Operations
sdram0_metadata.init_value=0xD                        # (int   , init-time) default = '0xD'    : Initialize metadata memory with this value. : [0x0..0xF]
sdram1_metadata.init_value=0xD                        # (int   , init-time) default = '0xD'    : Initialize metadata memory with this value. : [0x0..0xF]
trickbox.trace=0x0                                    # (int   , run-time ) default = '0x0'    : Trace level
trickbox.tube_len=0xFF                                # (int   , run-time ) default = '0xFF'   : Buffer length for tube output
trickbox.tube_verbose=0xFF                            # (int   , run-time ) default = '0xFF'   : Output extra data with tube lines (cpu IDs)
trickbox.full_shutdown=0                              # (bool  , init-time) default = '0'      : Perform full shutdown
trickbox.exit_trigger=0x0                             # (int   , init-time) default = '0x0'    : Exit simulation when - 0: 0x4 output on tube; 1: all cores in WFI : [0x0..0x1]
trickbox.tube_filename=""                             # (string, init-time) default = ''       : Tube output file path
trickbox.can_abort_normal=1                           # (bool  , init-time) default = '1'      : Can raise aborts in Normal memory
trickbox.disable_watchdog=0                           # (bool  , init-time) default = '0'      : Disable the trickbox watchdog
trickbox.legacy-interrupt-as-SPI=0                    # (bool  , init-time) default = '0'      : generate trickbox IRQ/FIQ as SPIs
trickbox.SPI-id-irq0=0x30                             # (int   , init-time) default = '0x30'   : SPI id value for irq replacement for cpu 0
trickbox.SPI-id-irq1=0x31                             # (int   , init-time) default = '0x31'   : SPI id value for irq replacement for cpu 1
trickbox.SPI-id-irq2=0x32                             # (int   , init-time) default = '0x32'   : SPI id value for irq replacement for cpu 2
trickbox.SPI-id-irq3=0x33                             # (int   , init-time) default = '0x33'   : SPI id value for irq replacement for cpu 3
trickbox.SPI-id-irq4=0x34                             # (int   , init-time) default = '0x34'   : SPI id value for irq replacement for cpu 4
trickbox.SPI-id-irq5=0x35                             # (int   , init-time) default = '0x35'   : SPI id value for irq replacement for cpu 5
trickbox.SPI-id-irq6=0x36                             # (int   , init-time) default = '0x36'   : SPI id value for irq replacement for cpu 6
trickbox.SPI-id-irq7=0x37                             # (int   , init-time) default = '0x37'   : SPI id value for irq replacement for cpu 7
trickbox.SPI-id-fiq0=0x38                             # (int   , init-time) default = '0x38'   : SPI id value for fiq replacement for cpu 0
trickbox.SPI-id-fiq1=0x39                             # (int   , init-time) default = '0x39'   : SPI id value for fiq replacement for cpu 1
trickbox.SPI-id-fiq2=0x3A                             # (int   , init-time) default = '0x3A'   : SPI id value for fiq replacement for cpu 2
trickbox.SPI-id-fiq3=0x3B                             # (int   , init-time) default = '0x3B'   : SPI id value for fiq replacement for cpu 3
trickbox.SPI-id-fiq4=0x3C                             # (int   , init-time) default = '0x3C'   : SPI id value for fiq replacement for cpu 4
trickbox.SPI-id-fiq5=0x3D                             # (int   , init-time) default = '0x3D'   : SPI id value for fiq replacement for cpu 5
trickbox.SPI-id-fiq6=0x3E                             # (int   , init-time) default = '0x3E'   : SPI id value for fiq replacement for cpu 6
trickbox.SPI-id-fiq7=0x3F                             # (int   , init-time) default = '0x3F'   : SPI id value for fiq replacement for cpu 7
trickbox.has_v8r_scratchpad=0                         # (bool  , init-time) default = '0'      : Supports V8R scratchpad registers at 0x1080
trickbox.asd_modifies_data=0                          # (bool  , init-time) default = '0'      : GTE Access Sensitive Device modifies read and write data
trickbox.non_aborting_region_size=0x1000000           # (int   , init-time) default = '0x1000000' : Size of region from trickbox_base which is non aborting
trickbox.output_attributes_parameter_of_core="ExtendedID[62:55]=MPAM_PMG, ExtendedID[54:39]=MPAM_PARTID, ExtendedID[38]=MPAM_NS"  # (string, init-time) default = 'ExtendedID[62:55]=MPAM_PMG, ExtendedID[54:39]=MPAM_PARTID, ExtendedID[38]=MPAM_NS' : This is the exact value used by the core's "output_attributes" parameter. It encodes the transform the core applies to encode various attributes on the bus. The trickbox then has to know the transform in order to decode the attributes.
l2cc.cache-state_modelled=0                           # (bool  , init-time) default = '0'      : Specifies whether real cache state is modelled (vs. register model)
l2cc.ASSOCIATIVITY=0x0                                # (int   , init-time) default = '0x0'    : Associativity for Auxiliary Control Register : [0x0..0x1]
l2cc.CACHEID=0x0                                      # (int   , init-time) default = '0x0'    : Cache controller cache ID : [0x0..0x3F]
l2cc.WAYSIZE=0x1                                      # (int   , init-time) default = '0x1'    : Size of ways for Auxiliary Control Register : [0x0..0x7]
l2cc.CFGBIGEND=0x0                                    # (int   , init-time) default = '0x0'    : Big-endian mode for accessing configuration registers out of reset : [0x0..0x1]
l2cc.LOCKDOWN_BY_MASTER=0x0                           # (int   , init-time) default = '0x0'    : Lockdown by master - value is reflected in CacheType register Bit 26, but the feature is not switched off when the parameter is 0 : [0x0..0x1]
l2cc.LOCKDOWN_BY_LINE=0x0                             # (int   , init-time) default = '0x0'    : Lockdown by line - value is reflected in CacheType register Bit 25, but the feature is not switched off when the parameter is 0 : [0x0..0x1]
l2cc.delay_cache_miss=0x0                             # (int   , init-time) default = '0x0'    : Cost to handle a cache miss : [0x0..0x3B9ACA00]
l2cc.delay_cache_hit=0x0                              # (int   , init-time) default = '0x0'    : Cost to handle a cache hit : [0x0..0x3B9ACA00]
l2cc.delay_cache_perbeat=0x0                          # (int   , init-time) default = '0x0'    : Cost to handle one beat of cache data movement : [0x0..0x3B9ACA00]
trickbox_switch.pvbus_mapper.handling_of_dvm_messages_from_upstream="forward"  # (string, init-time) default = 'forward' : What to do with DVM (Distributed Virtual Memory) messages received from upstream.  The options are to 'forward' them downstream unaltered, to 'terminate' them, or to 'handle' them locally and get called through handleUpstreamDVMMessage()
trickbox_switch.pvbus_mapper.handling_of_dvm_messages_from_downstream="forward"  # (string, init-time) default = 'forward' : What to do with DVM (Distributed Virtual Memory) messages received from downstream.  The options are to 'forward' them upstream unaltered, to 'terminate' them, or to 'handle' them locally and get called through handleDownstreamDVMMessage()
trickbox_switch.pvbus_mapper.handling_of_upstream_snoop_requests="forward"  # (string, init-time) default = 'forward' : What to do with snoop requests from downstream.  The options are to 'forward', 'terminate' or 'handle'.  NOTE that currently the snoop request addresses are _not_ translated and so if your device alters the address translation then you will almost certainly want to 'terminate'.
filter_switch.pvbus_mapper.handling_of_dvm_messages_from_upstream="forward"  # (string, init-time) default = 'forward' : What to do with DVM (Distributed Virtual Memory) messages received from upstream.  The options are to 'forward' them downstream unaltered, to 'terminate' them, or to 'handle' them locally and get called through handleUpstreamDVMMessage()
filter_switch.pvbus_mapper.handling_of_dvm_messages_from_downstream="forward"  # (string, init-time) default = 'forward' : What to do with DVM (Distributed Virtual Memory) messages received from downstream.  The options are to 'forward' them upstream unaltered, to 'terminate' them, or to 'handle' them locally and get called through handleDownstreamDVMMessage()
filter_switch.pvbus_mapper.handling_of_upstream_snoop_requests="forward"  # (string, init-time) default = 'forward' : What to do with snoop requests from downstream.  The options are to 'forward', 'terminate' or 'handle'.  NOTE that currently the snoop request addresses are _not_ translated and so if your device alters the address translation then you will almost certainly want to 'terminate'.
v8ect.number-of-channels=0x4                          # (int   , init-time) default = '0x4'    : Number of channels in cross trigger matrix : [0x3..0x20]
v8ect.has_CTIAUTHSTATUS=1                             # (bool  , init-time) default = '1'      : Has the optional CTIAUTHSTATUS register
dap.ap1_rom_base_address=0x0                          # (int   , init-time) default = '0x0'    : ROM base address for AP 1
dap.ap1_has_debug_rom=0                               # (bool  , init-time) default = '0'      : Whether AP1 has a Debug ROM
dap.ap0_set_paddrdbg31=0                              # (bool  , init-time) default = '0'      : Set paddrdbg31 signal during accesses on AP0
dap.ap1_set_paddrdbg31=0                              # (bool  , init-time) default = '0'      : Set paddrdbg31 signal during accesses on AP1
dapmemlogger.trace_snoops=0                           # (bool  , init-time) default = '0'      : Enable tracing of ACE snoop requests
dapmemlogger.trace_debug=0                            # (bool  , init-time) default = '0'      : Enable tracing of debug transactions
ext_obs_external_pvbus_m_pvbus1_to_2_bridge.handling_of_dvm_messages_from_upstream="forward"  # (string, init-time) default = 'forward' : What to do with DVM (Distributed Virtual Memory) messages received from upstream.  The options are to 'forward' them downstream unaltered, to 'terminate' them, or to 'handle' them locally and get called through handleUpstreamDVMMessage()
ext_obs_external_pvbus_m_pvbus1_to_2_bridge.handling_of_dvm_messages_from_downstream="forward"  # (string, init-time) default = 'forward' : What to do with DVM (Distributed Virtual Memory) messages received from downstream.  The options are to 'forward' them upstream unaltered, to 'terminate' them, or to 'handle' them locally and get called through handleDownstreamDVMMessage()
ext_obs_external_pvbus_m_pvbus1_to_2_bridge.handling_of_upstream_snoop_requests="forward"  # (string, init-time) default = 'forward' : What to do with snoop requests from downstream.  The options are to 'forward', 'terminate' or 'handle'.  NOTE that currently the snoop request addresses are _not_ translated and so if your device alters the address translation then you will almost certainly want to 'terminate'.
gic_distributor.STATUSR-implemented=1                 # (bool  , init-time) default = '1'      : Determines whether the GICR_STATUSR register is implemented.
gic_distributor.reg-base=0x2C010000                   # (int   , init-time) default = '0x2C010000' : Base for decoding GICv3 registers.
gic_distributor.reg-base-per-redistributor=""         # (string, init-time) default = ''       : Base address for each redistributor in the form '0.0.0.0=0x2c010000, 0.0.0.1=0x2c020000'.  All redistributors must be specified and this overrides the reg-base parameter (except that reg-base will still be used for the top-level redistributor).
gic_distributor.GICD-alias=0x0                        # (int   , init-time) default = '0x0'    : In GICv2 mode: the base address for a 4k page alias of the first 4k of the Distributor page, in GICv3 mode. the base address of a 64KB page containing message based SPI signalling register aliases(0:Disabled)
gic_distributor.has-two-security-states=1             # (bool  , init-time) default = '1'      : If true, has two security states
gic_distributor.IIDR=0x0                              # (int   , init-time) default = '0x0'    : GICD_IIDR and GICR_IIDR value : [0x0..0xFFFFFFFF]
gic_distributor.priority-bits=0x5                     # (int   , init-time) default = '0x5'    : Number of implemented priority bits : [0x4..0x8]
gic_distributor.ICFGR-SGI-mask=0x0                    # (int   , init-time) default = '0x0'    : Mask for writes to ICFGR registers that configure SGIs : [0x0..0xFFFFFFFF]
gic_distributor.ICFGR-PPI-mask=0xAAAAAAAA             # (int   , init-time) default = '0xAAAAAAAA' : Mask for writes to ICFGR registers that configure PPIs : [0x0..0xFFFFFFFF]
gic_distributor.ICFGR-SPI-mask=0xAAAAAAAA             # (int   , init-time) default = '0xAAAAAAAA' : Mask for writes to ICFGR registers that configure SPIs : [0x0..0xFFFFFFFF]
gic_distributor.ICFGR-SGI-reset=0xAAAAAAAA            # (int   , init-time) default = '0xAAAAAAAA' : Reset value for ICFGR registers that configure SGIs : [0x0..0xFFFFFFFF]
gic_distributor.ICFGR-PPI-reset=0x0                   # (int   , init-time) default = '0x0'    : Reset value for ICFGR regesters that configure PPIs : [0x0..0xFFFFFFFF]
gic_distributor.ICFGR-SPI-reset=0x0                   # (int   , init-time) default = '0x0'    : Reset value for ICFGR regesters that configure SPIs : [0x0..0xFFFFFFFF]
gic_distributor.ICFGR-rsvd-bit=0                      # (bool  , init-time) default = '0'      : If ARE=0, the value of reserved bits i.e. bit 0,2,4..30 of ICFGRn for n>0
gic_distributor.IGROUP-SGI-mask=0xFFFF                # (int   , init-time) default = '0xFFFF' : Mask for writes to SGI bits in IGROUP registers : [0x0..0xFFFF]
gic_distributor.IGROUP-PPI-mask=0xFFFF                # (int   , init-time) default = '0xFFFF' : Mask for writes to PPI bits in IGROUP registers : [0x0..0xFFFF]
gic_distributor.IGROUP-SGI-reset=0x0                  # (int   , init-time) default = '0x0'    : Reset value for SGI bits in IGROUP registers : [0x0..0xFFFF]
gic_distributor.IGROUP-PPI-reset=0x0                  # (int   , init-time) default = '0x0'    : Reset value for SGI bits in IGROUP registers : [0x0..0xFFFF]
gic_distributor.PPI-implemented-mask=0xFFFF           # (int   , init-time) default = '0xFFFF' : Mask of PPIs that are implemented. One bit per PPI bit 0 == PPI 16 (first PPI). This will affect other masks. : [0x0..0xFFFF]
gic_distributor.SPI-count=0xE0                        # (int   , init-time) default = '0xE0'   : Number of SPIs that are implemented. : [0x0..0x3DC]
gic_distributor.lockable-SPI-count=0x0                # (int   , init-time) default = '0x0'    : Number of SPIs that are locked down when CFGSDISABLE signal is asserted.  Only applies for GICv2. : [0x0..0x1F]
gic_distributor.has-gicv3=1                           # (bool  , init-time) default = '1'      : Enable GICv3 functionality; when false the component is inactive.
gic_distributor.print-memory-map=0                    # (bool  , init-time) default = '0'      : Print memory map to stdout
gic_distributor.GICD_PIDR=0x0                         # (int   , init-time) default = '0x0'    : The value for the GICD_PIDR registers, if non-zero. Note: fixed fields (device type etc.) will be overriden in this value.
gic_distributor.GICR_PIDR=0x0                         # (int   , init-time) default = '0x0'    : The value for the GICR_PIDR registers, if non-zero. Note: fixed fields (device type etc.) will be overriden in this value.
gic_distributor.IRI-ID-bits=0x10                      # (int   , init-time) default = '0x10'   : Number of bits used to represent interrupts IDs in the Distributor and Redistributors, forced to 10 if LPIs are not supported : [0xE..0x18]
gic_distributor.ITS-count=0x0                         # (int   , init-time) default = '0x0'    : Number of Interrupt Translation Services to be instantiated (0=none) : [0x0..0x4]
gic_distributor.GITS_PIDR=0x0                         # (int   , init-time) default = '0x0'    : The value for the GITS_PIDR registers, if non-zero. Note: fixed fields (device type etc.) will be overriden in this value.
gic_distributor.monolithic=0                          # (bool  , init-time) default = '0'      : Indicate that the implementation is not distributed
gic_distributor.ITS0-base=0x0                         # (int   , init-time) default = '0x0'    : Register base address for ITS0 (automatic if 0).
gic_distributor.ITS1-base=0x0                         # (int   , init-time) default = '0x0'    : Register base address for ITS1 (automatic if 0).
gic_distributor.ITS2-base=0x0                         # (int   , init-time) default = '0x0'    : Register base address for ITS2 (automatic if 0).
gic_distributor.ITS3-base=0x0                         # (int   , init-time) default = '0x0'    : Register base address for ITS3 (automatic if 0).
gic_distributor.processor-numbers=""                  # (string, init-time) default = ''       : Specify processor numbers (as appears in GICR_TYPER) in the form 0.0.0.0=0,0.0.0.1=1 etc.) If not specified, will number processors starting at 0.
gic_distributor.GITS_BASER0-type=0x0                  # (int   , init-time) default = '0x0'    : Type field for GITS_BASER0 register. 0 = Unimplemented; 1 = Devices; 2 = Virtual Processors; 3 = Physical Processors; 4 = Collections : [0x0..0x4]
gic_distributor.GITS_BASER1-type=0x0                  # (int   , init-time) default = '0x0'    : Type field for GITS_BASER1 register. 0 = Unimplemented; 1 = Devices; 2 = Virtual Processors; 3 = Physical Processors; 4 = Collections : [0x0..0x4]
gic_distributor.GITS_BASER2-type=0x0                  # (int   , init-time) default = '0x0'    : Type field for GITS_BASER2 register. 0 = Unimplemented; 1 = Devices; 2 = Virtual Processors; 3 = Physical Processors; 4 = Collections : [0x0..0x4]
gic_distributor.GITS_BASER3-type=0x0                  # (int   , init-time) default = '0x0'    : Type field for GITS_BASER3 register. 0 = Unimplemented; 1 = Devices; 2 = Virtual Processors; 3 = Physical Processors; 4 = Collections : [0x0..0x4]
gic_distributor.GITS_BASER4-type=0x0                  # (int   , init-time) default = '0x0'    : Type field for GITS_BASER4 register. 0 = Unimplemented; 1 = Devices; 2 = Virtual Processors; 3 = Physical Processors; 4 = Collections : [0x0..0x4]
gic_distributor.GITS_BASER5-type=0x0                  # (int   , init-time) default = '0x0'    : Type field for GITS_BASER5 register. 0 = Unimplemented; 1 = Devices; 2 = Virtual Processors; 3 = Physical Processors; 4 = Collections : [0x0..0x4]
gic_distributor.GITS_BASER6-type=0x0                  # (int   , init-time) default = '0x0'    : Type field for GITS_BASER6 register. 0 = Unimplemented; 1 = Devices; 2 = Virtual Processors; 3 = Physical Processors; 4 = Collections : [0x0..0x4]
gic_distributor.GITS_BASER7-type=0x0                  # (int   , init-time) default = '0x0'    : Type field for GITS_BASER7 register. 0 = Unimplemented; 1 = Devices; 2 = Virtual Processors; 3 = Physical Processors; 4 = Collections : [0x0..0x4]
gic_distributor.GITS_BASER0-entry-bytes=0x8           # (int   , init-time) default = '0x8'    : Number of bytes required per entry for GITS_BASER0 register. : [0x1..0x100]
gic_distributor.GITS_BASER1-entry-bytes=0x8           # (int   , init-time) default = '0x8'    : Number of bytes required per entry for GITS_BASER1 register. : [0x1..0x100]
gic_distributor.GITS_BASER2-entry-bytes=0x8           # (int   , init-time) default = '0x8'    : Number of bytes required per entry for GITS_BASER2 register. : [0x1..0x100]
gic_distributor.GITS_BASER3-entry-bytes=0x8           # (int   , init-time) default = '0x8'    : Number of bytes required per entry for GITS_BASER3 register. : [0x1..0x100]
gic_distributor.GITS_BASER4-entry-bytes=0x8           # (int   , init-time) default = '0x8'    : Number of bytes required per entry for GITS_BASER4 register. : [0x1..0x100]
gic_distributor.GITS_BASER5-entry-bytes=0x8           # (int   , init-time) default = '0x8'    : Number of bytes required per entry for GITS_BASER5 register. : [0x1..0x100]
gic_distributor.GITS_BASER6-entry-bytes=0x8           # (int   , init-time) default = '0x8'    : Number of bytes required per entry for GITS_BASER6 register. : [0x1..0x100]
gic_distributor.GITS_BASER7-entry-bytes=0x8           # (int   , init-time) default = '0x8'    : Number of bytes required per entry for GITS_BASER7 register. : [0x1..0x100]
gic_distributor.GITS_BASER0-indirect-RAZ=0            # (bool  , init-time) default = '0'      : Indirect field for GITS_BASER0 register is RAZ/WI.
gic_distributor.GITS_BASER1-indirect-RAZ=0            # (bool  , init-time) default = '0'      : Indirect field for GITS_BASER1 register is RAZ/WI.
gic_distributor.GITS_BASER2-indirect-RAZ=0            # (bool  , init-time) default = '0'      : Indirect field for GITS_BASER2 register is RAZ/WI.
gic_distributor.GITS_BASER3-indirect-RAZ=0            # (bool  , init-time) default = '0'      : Indirect field for GITS_BASER3 register is RAZ/WI.
gic_distributor.GITS_BASER4-indirect-RAZ=0            # (bool  , init-time) default = '0'      : Indirect field for GITS_BASER4 register is RAZ/WI.
gic_distributor.GITS_BASER5-indirect-RAZ=0            # (bool  , init-time) default = '0'      : Indirect field for GITS_BASER5 register is RAZ/WI.
gic_distributor.GITS_BASER6-indirect-RAZ=0            # (bool  , init-time) default = '0'      : Indirect field for GITS_BASER6 register is RAZ/WI.
gic_distributor.GITS_BASER7-indirect-RAZ=0            # (bool  , init-time) default = '0'      : Indirect field for GITS_BASER7 register is RAZ/WI.
gic_distributor.supports-shareability=1               # (bool  , init-time) default = '1'      : Device supports shareability attributes on outgoing memory bus (i.e. is modelling an ACElite port rather than an AXI4 port).
gic_distributor.delay-redistributor-accesses=1        # (bool  , init-time) default = '1'      : Delay memory accesses from the redistributor until GICR_SYNCR is read.
gic_distributor.A3-affinity-supported=0               # (bool  , init-time) default = '0'      : Device supports affinity level 3 values that are non-zero.
gic_distributor.sgi-range-selector-support=0          # (bool  , init-time) default = '0'      : Device has support for the Range Selector feature for SGI
gic_distributor.GICR_PROPBASER-read-only=0            # (bool  , init-time) default = '0'      : GICR_PROPBASER register is read-only.
gic_distributor.GICR_PROPBASER-reset-value=0x0        # (int   , init-time) default = '0x0'    : Value of GICR_PROPBASER on reset.
gic_distributor.ITS-vmovp-bit=0                       # (bool  , init-time) default = '0'      : Device supports software issuing a VMOVP to only one of the ITSs that has a mapping for a vPE. The device itself ensures synchronization of the VMOVP command across all ITSs that have mapping for that vPE.
gic_distributor.ITS-device-bits=0x10                  # (int   , init-time) default = '0x10'   : Number of bits supported for ITS device IDs. : [0x1..0x20]
gic_distributor.ITS-entry-size=0x8                    # (int   , init-time) default = '0x8'    : Number of bytes required to store each entry in the ITT tables. : [0x1..0x400]
gic_distributor.ITS-ID-bits=0x10                      # (int   , init-time) default = '0x10'   : Number of interrupt bits supported by ITS. : [0xE..0x18]
gic_distributor.ITS-collection-ID-bits=0x0            # (int   , init-time) default = '0x0'    : Number of collection bits supported by ITS (optional parameter, 0 => 16bits support and GITS_TYPER.CIL=0 : [0x0..0x10]
gic_distributor.ITS-cumulative-collection-tables=1    # (bool  , init-time) default = '1'      : When true, the supported amount of collections is the sum of GITS_TYPER.HCC and the number of collections supported in memory, otherwise, simply the number supported in memory only. Irrelevant when HCC=0
gic_distributor.ITS-shared-vPE-table=0x0              # (int   , init-time) default = '0x0'    : Number of affinity levels to which the vPE configuration table is shared. : [0x0..0x3]
gic_distributor.delay-ITS-accesses=1                  # (bool  , init-time) default = '1'      : Delay accesses from the ITS until GICR_SYNCR is read.
gic_distributor.MSI_PIDR=0x0                          # (int   , init-time) default = '0x0'    : The value for the MSI_PIDR registers, if non-zero and distributor supports GICv2m. Note: fixed fields (device type etc.) will be overriden in this value.
gic_distributor.MSI_IIDR=0x0                          # (int   , init-time) default = '0x0'    : Value returned in MSI_IIDR registers. : [0x0..0xFFFFFFF]
gic_distributor.MSI_S-frame0-base=0x0                 # (int   , init-time) default = '0x0'    : If non-zero, sets the base address used for secure MSI frame 0 registers.
gic_distributor.MSI_S-frame1-base=0x0                 # (int   , init-time) default = '0x0'    : If non-zero, sets the base address used for secure MSI frame 1 registers.
gic_distributor.MSI_S-frame2-base=0x0                 # (int   , init-time) default = '0x0'    : If non-zero, sets the base address used for secure MSI frame 2 registers.
gic_distributor.MSI_S-frame3-base=0x0                 # (int   , init-time) default = '0x0'    : If non-zero, sets the base address used for secure MSI frame 3 registers.
gic_distributor.MSI_S-frame4-base=0x0                 # (int   , init-time) default = '0x0'    : If non-zero, sets the base address used for secure MSI frame 4 registers.
gic_distributor.MSI_S-frame5-base=0x0                 # (int   , init-time) default = '0x0'    : If non-zero, sets the base address used for secure MSI frame 5 registers.
gic_distributor.MSI_S-frame6-base=0x0                 # (int   , init-time) default = '0x0'    : If non-zero, sets the base address used for secure MSI frame 6 registers.
gic_distributor.MSI_S-frame7-base=0x0                 # (int   , init-time) default = '0x0'    : If non-zero, sets the base address used for secure MSI frame 7 registers.
gic_distributor.MSI_S-frame0-min-SPI=0x0              # (int   , init-time) default = '0x0'    : Minimum SPI ID supported by secure MSI frame 0. Set to 0 to disable frame. : [0x0..0x3FB]
gic_distributor.MSI_S-frame1-min-SPI=0x0              # (int   , init-time) default = '0x0'    : Minimum SPI ID supported by secure MSI frame 1. Set to 0 to disable frame. : [0x0..0x3FB]
gic_distributor.MSI_S-frame2-min-SPI=0x0              # (int   , init-time) default = '0x0'    : Minimum SPI ID supported by secure MSI frame 2. Set to 0 to disable frame. : [0x0..0x3FB]
gic_distributor.MSI_S-frame3-min-SPI=0x0              # (int   , init-time) default = '0x0'    : Minimum SPI ID supported by secure MSI frame 3. Set to 0 to disable frame. : [0x0..0x3FB]
gic_distributor.MSI_S-frame4-min-SPI=0x0              # (int   , init-time) default = '0x0'    : Minimum SPI ID supported by secure MSI frame 4. Set to 0 to disable frame. : [0x0..0x3FB]
gic_distributor.MSI_S-frame5-min-SPI=0x0              # (int   , init-time) default = '0x0'    : Minimum SPI ID supported by secure MSI frame 5. Set to 0 to disable frame. : [0x0..0x3FB]
gic_distributor.MSI_S-frame6-min-SPI=0x0              # (int   , init-time) default = '0x0'    : Minimum SPI ID supported by secure MSI frame 6. Set to 0 to disable frame. : [0x0..0x3FB]
gic_distributor.MSI_S-frame7-min-SPI=0x0              # (int   , init-time) default = '0x0'    : Minimum SPI ID supported by secure MSI frame 7. Set to 0 to disable frame. : [0x0..0x3FB]
gic_distributor.MSI_S-frame0-max-SPI=0x0              # (int   , init-time) default = '0x0'    : Maximum SPI ID supported by secure MSI frame 0. Set to 0 to disable frame. : [0x0..0x3FB]
gic_distributor.MSI_S-frame1-max-SPI=0x0              # (int   , init-time) default = '0x0'    : Maximum SPI ID supported by secure MSI frame 1. Set to 0 to disable frame. : [0x0..0x3FB]
gic_distributor.MSI_S-frame2-max-SPI=0x0              # (int   , init-time) default = '0x0'    : Maximum SPI ID supported by secure MSI frame 2. Set to 0 to disable frame. : [0x0..0x3FB]
gic_distributor.MSI_S-frame3-max-SPI=0x0              # (int   , init-time) default = '0x0'    : Maximum SPI ID supported by secure MSI frame 3. Set to 0 to disable frame. : [0x0..0x3FB]
gic_distributor.MSI_S-frame4-max-SPI=0x0              # (int   , init-time) default = '0x0'    : Maximum SPI ID supported by secure MSI frame 4. Set to 0 to disable frame. : [0x0..0x3FB]
gic_distributor.MSI_S-frame5-max-SPI=0x0              # (int   , init-time) default = '0x0'    : Maximum SPI ID supported by secure MSI frame 5. Set to 0 to disable frame. : [0x0..0x3FB]
gic_distributor.MSI_S-frame6-max-SPI=0x0              # (int   , init-time) default = '0x0'    : Maximum SPI ID supported by secure MSI frame 6. Set to 0 to disable frame. : [0x0..0x3FB]
gic_distributor.MSI_S-frame7-max-SPI=0x0              # (int   , init-time) default = '0x0'    : Maximum SPI ID supported by secure MSI frame 7. Set to 0 to disable frame. : [0x0..0x3FB]
gic_distributor.MSI_NS-frame0-base=0x0                # (int   , init-time) default = '0x0'    : If non-zero, sets the base address used for non-secure MSI frame 0 registers.
gic_distributor.MSI_NS-frame1-base=0x0                # (int   , init-time) default = '0x0'    : If non-zero, sets the base address used for non-secure MSI frame 1 registers.
gic_distributor.MSI_NS-frame2-base=0x0                # (int   , init-time) default = '0x0'    : If non-zero, sets the base address used for non-secure MSI frame 2 registers.
gic_distributor.MSI_NS-frame3-base=0x0                # (int   , init-time) default = '0x0'    : If non-zero, sets the base address used for non-secure MSI frame 3 registers.
gic_distributor.MSI_NS-frame4-base=0x0                # (int   , init-time) default = '0x0'    : If non-zero, sets the base address used for non-secure MSI frame 4 registers.
gic_distributor.MSI_NS-frame5-base=0x0                # (int   , init-time) default = '0x0'    : If non-zero, sets the base address used for non-secure MSI frame 5 registers.
gic_distributor.MSI_NS-frame6-base=0x0                # (int   , init-time) default = '0x0'    : If non-zero, sets the base address used for non-secure MSI frame 6 registers.
gic_distributor.MSI_NS-frame7-base=0x0                # (int   , init-time) default = '0x0'    : If non-zero, sets the base address used for non-secure MSI frame 7 registers.
gic_distributor.MSI_NS-frame0-min-SPI=0x0             # (int   , init-time) default = '0x0'    : Minimum SPI ID supported by non-secure MSI frame 0. Set to 0 to disable frame. : [0x0..0x3FB]
gic_distributor.MSI_NS-frame1-min-SPI=0x0             # (int   , init-time) default = '0x0'    : Minimum SPI ID supported by non-secure MSI frame 1. Set to 0 to disable frame. : [0x0..0x3FB]
gic_distributor.MSI_NS-frame2-min-SPI=0x0             # (int   , init-time) default = '0x0'    : Minimum SPI ID supported by non-secure MSI frame 2. Set to 0 to disable frame. : [0x0..0x3FB]
gic_distributor.MSI_NS-frame3-min-SPI=0x0             # (int   , init-time) default = '0x0'    : Minimum SPI ID supported by non-secure MSI frame 3. Set to 0 to disable frame. : [0x0..0x3FB]
gic_distributor.MSI_NS-frame4-min-SPI=0x0             # (int   , init-time) default = '0x0'    : Minimum SPI ID supported by non-secure MSI frame 4. Set to 0 to disable frame. : [0x0..0x3FB]
gic_distributor.MSI_NS-frame5-min-SPI=0x0             # (int   , init-time) default = '0x0'    : Minimum SPI ID supported by non-secure MSI frame 5. Set to 0 to disable frame. : [0x0..0x3FB]
gic_distributor.MSI_NS-frame6-min-SPI=0x0             # (int   , init-time) default = '0x0'    : Minimum SPI ID supported by non-secure MSI frame 6. Set to 0 to disable frame. : [0x0..0x3FB]
gic_distributor.MSI_NS-frame7-min-SPI=0x0             # (int   , init-time) default = '0x0'    : Minimum SPI ID supported by non-secure MSI frame 7. Set to 0 to disable frame. : [0x0..0x3FB]
gic_distributor.MSI_NS-frame0-max-SPI=0x0             # (int   , init-time) default = '0x0'    : Maximum SPI ID supported by non-secure MSI frame 0. Set to 0 to disable frame. : [0x0..0x3FB]
gic_distributor.MSI_NS-frame1-max-SPI=0x0             # (int   , init-time) default = '0x0'    : Maximum SPI ID supported by non-secure MSI frame 1. Set to 0 to disable frame. : [0x0..0x3FB]
gic_distributor.MSI_NS-frame2-max-SPI=0x0             # (int   , init-time) default = '0x0'    : Maximum SPI ID supported by non-secure MSI frame 2. Set to 0 to disable frame. : [0x0..0x3FB]
gic_distributor.MSI_NS-frame3-max-SPI=0x0             # (int   , init-time) default = '0x0'    : Maximum SPI ID supported by non-secure MSI frame 3. Set to 0 to disable frame. : [0x0..0x3FB]
gic_distributor.MSI_NS-frame4-max-SPI=0x0             # (int   , init-time) default = '0x0'    : Maximum SPI ID supported by non-secure MSI frame 4. Set to 0 to disable frame. : [0x0..0x3FB]
gic_distributor.MSI_NS-frame5-max-SPI=0x0             # (int   , init-time) default = '0x0'    : Maximum SPI ID supported by non-secure MSI frame 5. Set to 0 to disable frame. : [0x0..0x3FB]
gic_distributor.MSI_NS-frame6-max-SPI=0x0             # (int   , init-time) default = '0x0'    : Maximum SPI ID supported by non-secure MSI frame 6. Set to 0 to disable frame. : [0x0..0x3FB]
gic_distributor.MSI_NS-frame7-max-SPI=0x0             # (int   , init-time) default = '0x0'    : Maximum SPI ID supported by non-secure MSI frame 7. Set to 0 to disable frame. : [0x0..0x3FB]
gic_distributor.local-SEIs=0                          # (bool  , init-time) default = '0'      : Generate SEI to signal internal issues
gic_distributor.local-VSEIs=0                         # (bool  , init-time) default = '0'      : Generate VSEI to signal internal issues
gic_distributor.virtual-priority-bits=0x5             # (int   , init-time) default = '0x5'    : Number of implemented virtual priority bits : [0x5..0x8]
gic_distributor.ITS-hardware-collection-count=0x0     # (int   , init-time) default = '0x0'    : Number of hardware collections held exclusively in the ITS : [0x0..0xFF]
gic_distributor.ITS-MOVALL-update-collections=0       # (bool  , init-time) default = '0'      : Whether MOVALL command updates the collection entires
gic_distributor.ITS-use-physical-target-addresses=1   # (bool  , init-time) default = '1'      : Use physical hardware adresses for targets in ITS commands -- must be true for distributed implementations
gic_distributor.ITS-threaded-command-queue=1          # (bool  , init-time) default = '1'      : Enable execution of ITS commands in a separate thread which is sometimes required for cosimulation
gic_distributor.ITS-legacy-iidr-typer-offset=0        # (bool  , init-time) default = '0'      : Put the GITS_IIDR and GITS_TYPER registers at their older offset of 0x8 and 0x4 respectively
gic_distributor.ITS-TRANSLATE64R=0                    # (bool  , init-time) default = '0'      : Add an implementation specific register at 0x10008 supporting 64 bit TRANSLATER (dev[63:32], interupt[31:0])
gic_distributor.ITS-BASER-force-page-alignement=1     # (bool  , init-time) default = '1'      : Force alignement of address writen to a GITS_BASER register to the page size configured
gic_distributor.redistributor-threaded-sync=1         # (bool  , init-time) default = '1'      : Enable execution of redistributor delayed transactions in a separate thread which is sometimes required for cosimulation
gic_distributor.enable_protocol_checking=0            # (bool  , init-time) default = '0'      : Enable/disable protocol checking at cpu interface
gic_distributor.DS-fixed-to-zero=0                    # (bool  , init-time) default = '0'      : Enable/disable support of single security state
gic_distributor.fixed-routed-spis=""                  # (string, init-time) default = ''       : Value of IROUTER[n] register in the form 'n=a.b.c.d, n=*'. The RM bit of IROUTER is 0 when n=a.b.c.d is used else 1 when n=* is used. n can be >= 32 and <= 1019
gic_distributor.irouter-default-mask=""               # (string, init-time) default = ''       : Default Mask value for IROUTER[32..1019] register in the form 'a.b.c.d'
gic_distributor.irouter-default-reset=""              # (string, init-time) default = ''       : Default Reset Value of IROUTER[32..1019] register in the form 'a.b.c.d' or *
gic_distributor.irouter-reset-values=""               # (string, init-time) default = ''       : Reset Value of IROUTER[n] register in the form 'n=a.b.c.d or n=*'.n can be >= 32 and <= 1019
gic_distributor.irouter-mask-values=""                # (string, init-time) default = ''       : Mask Value of IROUTER[n] register in the form 'n=a.b.c.d'.n can be >= 32 and <= 1019
gic_distributor.wakeup-on-reset=0                     # (bool  , init-time) default = '0'      : Go against specification and start redistributors in woken-up state at reset. This allows software that was written for previous versions of the GICv3 specification to work correctly. This should not be used for production code or when the distributor is used separately from the core fast model.
gic_distributor.ignore-generate-sgi-when-no-are=0     # (bool  , init-time) default = '0'      : Ignore GenerateSGI packets coming form the CPU interface if both ARE_S and ARE_NS are 0
gic_distributor.trace-speculative-lpi-property-update=0  # (bool  , init-time) default = '0'      : Trace LPI propery updates performed on speculative accesses (useful for debuging LPI)
gic_distributor.virtual-lpi-support=0                 # (bool  , init-time) default = '0'      : GICv4 Virtual LPIs and Direct injection of Virtual LPIs supported
gic_distributor.LPI-cache-type=0x1                    # (int   , init-time) default = '0x1'    : Cache type for LPIs, 0:No caching, 1:Full caching : [0x0..0x1]
gic_distributor.LPI-cache-check-data=0                # (bool  , init-time) default = '0'      : Enable Cached LPI data against memory checking when available for cache type
gic_distributor.DPG-bits-implemented=0                # (bool  , init-time) default = '0'      : Enable implementation of interrupt group participation bits or DPG bits in GICR_CTLR
gic_distributor.DPG-ARE-only=0                        # (bool  , init-time) default = '0'      : Limit application of DPG bits to interrupt groups for which ARE=1
gic_distributor.legacy-sgi-enable-rao=0               # (bool  , init-time) default = '0'      : Enables for SGI associated with an ARE=0 regime are RAO/WI
gic_distributor.ARE-fixed-to-one=0                    # (bool  , init-time) default = '0'      : GICv2 compatibility is not supported and GICD_CTLR.ARE_* is always one
gic_distributor.PA_SIZE=0x30                          # (int   , init-time) default = '0x30'   : Number of valid bits in physical address : [0x18..0x34]
gic_distributor.SPI-message-based-support=1           # (bool  , init-time) default = '1'      : Distributor supports meassage based signaling of SPI
gic_distributor.SPI-unimplemented=""                  # (string, init-time) default = ''       : A comma spearated list of unimplemented SPIs ranges for sparse SPI defintion(for ex: '35, 39-42, 73)'
gic_distributor.IROUTER-IRM-RAZ-WI=0                  # (bool  , init-time) default = '0'      : GICD_IROUTERn.InterruptRoutingMode is RAZ/WI
gic_distributor.outer-cacheability-support=0          # (bool  , init-time) default = '0'      : Allow configuration of outer cachability attributes in ITS and Redistributor
gic_distributor.direct-lpi-support=0                  # (bool  , init-time) default = '0'      : Enable support for LPI operations through GICR registers
gic_distributor.common-lpi-configuration=0x0          # (int   , init-time) default = '0x0'    : Describes which re-distributors share (and must be configured with the same) LPI configuration table as described in GICR_TYPER( 0:All, 1:A.x.x.x, 2:A.B.x.x, 3:A.B.C.x : [0x0..0x3]
gic_distributor.single-set-support=0                  # (bool  , init-time) default = '0'      : When true, forces redistributors to recall interrupts with a clear rather than issue a second Set command
gic_distributor.has_mpam=0                            # (bool  , init-time) default = '0'      : Enable MPAM support on ITS and RDs
gic_distributor.mpam_partid_max=0xFFFF                # (int   , init-time) default = '0xFFFF' : Maximum valid PARTID : [0x0..0xFFFF]
gic_distributor.mpam_pmg_max=0xFF                     # (int   , init-time) default = '0xFF'   : Maximum valid PMG : [0x0..0xFF]
gic_distributor.output_attributes="ExtendedID[62:55]=MPAM_PMG, ExtendedID[54:39]=MPAM_PARTID, ExtendedID[38]=MPAM_NS"  # (string, init-time) default = 'ExtendedID[62:55]=MPAM_PMG, ExtendedID[54:39]=MPAM_PARTID, ExtendedID[38]=MPAM_NS' : User-defined transform to be applied to bus attributes like MasterID, ExtendedID or UserFlags. Currently, only works for MPAM Attributes encoding into bus attributes.
gic_distributor.has_VPENDBASER-dirty-flag-on-load=0   # (bool  , init-time) default = '0'      : GICR_VPENDBASER.Dirty reflects transient loading state when valid=1
gic_distributor.allow-LPIEN-clear=0                   # (bool  , init-time) default = '0'      : Allow RW behaviour on GICR_CTLR.LPIEN isntead of set once
gic_distributor.extended-spi-count=0x0                # (int   , init-time) default = '0x0'    : Number of extended SPI supported : [0x0..0x400]
gic_distributor.extended-ppi-count=0x0                # (int   , init-time) default = '0x0'    : Number of extended PPI supported : [0x0..0x40]
gic_distributor.consolidators=""                      # (string, init-time) default = ''       : Specify consolidators' base addresses, interrupt line counts and base interrupt IDs, in the form 'baseAddr0:itlineCount0:baseINTID0, baseAddr1:itlineCount1:baseINTID1, [etc]' (eg '0x3f100000:64:4096, 0x3f200000:64:4224'). The consolidators' count is inferred from the list (maximum of 4). If not specified, the component contains no consolidators.
gic_distributor.GICD-legacy-registers-as-reserved=0   # (bool  , init-time) default = '0'      : When ARE is RAO/WI, makes superfluous registers in GICD reserved ( including for the purpose of STATUSR updates)
globalcounter.non_arch_start_at_default=0             # (bool  , init-time) default = '0'      : Firmware is expected to enable the timer at boot time. However, turning this parameter on is a model-specific way of enabling the counter module out of reset.
globalcounter.base_frequency=0x5F5E100                # (int   , init-time) default = '0x5F5E100' : Reset value for CNTFID0, base frequency in Hz : [0x0..0xFFFFFFFF]
globalcounter.use_real_time=0                         # (bool  , init-time) default = '0'      : Update the Generic Timer counter at a real-time base frequency instead of simulator time
globalcounter.non_arch_fixed_frequency=0x0            # (int   , init-time) default = '0x0'    : If set, ignore CNTFID0 and instead use this frequency in Hz : [0x0..0xFFFFFFFF]
globalcounter.cntcidr0123_C=0x0                       # (int   , init-time) default = '0x0'    : Values to be returned for control-frame CIDR registers : [0x0..0xFFFFFFFF]
globalcounter.cntpidr0123_C=0x0                       # (int   , init-time) default = '0x0'    : Values to be returned for control-frame PIDR registers 0-3 : [0x0..0xFFFFFFFF]
globalcounter.cntpidr4567_C=0x0                       # (int   , init-time) default = '0x0'    : Values to be returned for control-frame PIDR registers 4-7 : [0x0..0xFFFFFFFF]
globalcounter.cntcidr0123_R=0x0                       # (int   , init-time) default = '0x0'    : Values to be returned for read-frame CIDR registers : [0x0..0xFFFFFFFF]
globalcounter.cntpidr0123_R=0x0                       # (int   , init-time) default = '0x0'    : Values to be returned for read-frame PIDR registers 0-3 : [0x0..0xFFFFFFFF]
globalcounter.cntpidr4567_R=0x0                       # (int   , init-time) default = '0x0'    : Values to be returned for read-frame PIDR registers 4-7 : [0x0..0xFFFFFFFF]
globalcounter.readonly_is_WI=0                        # (bool  , init-time) default = '0'      : Ignore (rather than failing) on writes to read-frame
globalcounter.diagnostics=0x0                         # (int   , init-time) default = '0x0'    : Diagnostics : [0x0..0x4]
globalcounter.has_counter_scaling=0                   # (bool  , init-time) default = '0'      : Implements ARMv8.4 generic counter scaling
counter_switch.pvbus_mapper.handling_of_dvm_messages_from_upstream="forward"  # (string, init-time) default = 'forward' : What to do with DVM (Distributed Virtual Memory) messages received from upstream.  The options are to 'forward' them downstream unaltered, to 'terminate' them, or to 'handle' them locally and get called through handleUpstreamDVMMessage()
counter_switch.pvbus_mapper.handling_of_dvm_messages_from_downstream="forward"  # (string, init-time) default = 'forward' : What to do with DVM (Distributed Virtual Memory) messages received from downstream.  The options are to 'forward' them upstream unaltered, to 'terminate' them, or to 'handle' them locally and get called through handleDownstreamDVMMessage()
counter_switch.pvbus_mapper.handling_of_upstream_snoop_requests="forward"  # (string, init-time) default = 'forward' : What to do with snoop requests from downstream.  The options are to 'forward', 'terminate' or 'handle'.  NOTE that currently the snoop request addresses are _not_ translated and so if your device alters the address translation then you will almost certainly want to 'terminate'.
TRACE.ArchMsg.trace-file=""                           # (string, init-time) default = ''       : ArchMsg output file
TRACE.ArchMsg.suppress_repeated=1                     # (bool  , init-time) default = '1'      : Suppress repeated messages from similar call sites
TRACE.ArchMsg.suppress_sources=""                     # (string, init-time) default = ''       : Space-separated list of components or events which should not be printed
TRACE.ArchMsg.suppress_categories="Why"               # (string, init-time) default = 'Why'    : Space-separated list of categories which should not be printed
TRACE.ArchMsg.exit_on_first_output=0                  # (bool  , init-time) default = '0'      : exit simulation process after first message written
DEBUG.DAPValPlugin.object-file=""                     # (string, init-time) default = ''       : Object to load
DEBUG.DAPValPlugin.read_latency=0x0                   # (int   , init-time) default = '0x0'    : latency of reads, measured in clock cycles : [0x0..0x3E8]
DEBUG.DAPValPlugin.write_latency=0x0                  # (int   , init-time) default = '0x0'    : latency of writes, measured in clock cycles : [0x0..0x3E8]
DEBUG.DAPValPlugin.quantum_size=0x0                   # (int   , init-time) default = '0x0'    : size of quantum, measured in clock cycles : [0x0..0xF4240]
SVE.ScalableVectorExtension.veclen=0x8                # (int   , init-time) default = '0x8'    : size of vector in uints of 64 bits : [0x2..0x20]
SVE.ScalableVectorExtension.unknown_value=0xDEADDEADDEADDEAD  # (int   , init-time) default = '0xDEADDEADDEADDEAD' : Simulated value for state that has UNKNOWN value after reset
SVE.ScalableVectorExtension.enable_at_reset=0         # (bool  , init-time) default = '0'      : Start with system registers set up for Scalable Vector Extension use
SVE.ScalableVectorExtension.disass_internal=0         # (bool  , init-time) default = '0'      : Use generated disassembler, lower quality disassembly but will always match the instruction decoder
SVE.ScalableVectorExtension.support_npot_vl=1         # (bool  , init-time) default = '1'      : Support non-(power of two) vector length
SVE.ScalableVectorExtension.fp_exception_set_tfv=1    # (bool  , init-time) default = '1'      : Set ESR_ELx.TFV during FP exception (trapped exception flags are valid)
SVE.ScalableVectorExtension.fp_exception_set_vecitr=0  # (bool  , init-time) default = '0'      : Set ESR_ELx.VECITR during FP exception (RES0 otherwise)
SVE.ScalableVectorExtension.fp_exception_report_lowest=0  # (bool  , init-time) default = '0'      : For multiple trapped FP exception, report the lowest lane in VECITR (otherwise, highest)
SVE.ScalableVectorExtension.clear_constrained_lanes=0x0  # (int   , init-time) default = '0x0'    : When constrained vector length increases, previously inaccessible bits are set to zero (0=never, 1=always, 2=if register was written meanwhile) : [0x0..0x2]
SVE.ScalableVectorExtension.disable_speculative_accesses=0  # (bool  , init-time) default = '0'      : All speculative memory accesses will behave as though faulting without accessing memory
SVE.ScalableVectorExtension.combine_movprfx_and_destructive=0  # (bool  , init-time) default = '0'      : Attempt to combine the execution of MOVPRFX and the following destructively encoded instruction
SVE.ScalableVectorExtension.undef_invalid_combined_movprfx=1  # (bool  , init-time) default = '1'      : If a combined MOVPRFX is invalid, raise UNDEF exception (otherwise NOP second half)
#----------------------------------------------------------------------------------------------
